// Code generated by counterfeiter. DO NOT EDIT.
package mongofakes

import (
	"context"
	"sync"

	"github.com/rleszilm/genms/mongo"
)

type FakeCollection struct {
	BulkWriteStub        func(context.Context, []mongo.WriteModel, ...*mongo.BulkWriteOptions) (*mongo.BulkWriteResult, error)
	bulkWriteMutex       sync.RWMutex
	bulkWriteArgsForCall []struct {
		arg1 context.Context
		arg2 []mongo.WriteModel
		arg3 []*mongo.BulkWriteOptions
	}
	bulkWriteReturns struct {
		result1 *mongo.BulkWriteResult
		result2 error
	}
	bulkWriteReturnsOnCall map[int]struct {
		result1 *mongo.BulkWriteResult
		result2 error
	}
	CloneStub        func(...*mongo.CollectionOptions) (mongo.Collection, error)
	cloneMutex       sync.RWMutex
	cloneArgsForCall []struct {
		arg1 []*mongo.CollectionOptions
	}
	cloneReturns struct {
		result1 mongo.Collection
		result2 error
	}
	cloneReturnsOnCall map[int]struct {
		result1 mongo.Collection
		result2 error
	}
	DatabaseStub        func() mongo.Database
	databaseMutex       sync.RWMutex
	databaseArgsForCall []struct {
	}
	databaseReturns struct {
		result1 mongo.Database
	}
	databaseReturnsOnCall map[int]struct {
		result1 mongo.Database
	}
	DeleteManyStub        func(context.Context, interface{}, ...*mongo.DeleteOptions) (*mongo.DeleteResult, error)
	deleteManyMutex       sync.RWMutex
	deleteManyArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 []*mongo.DeleteOptions
	}
	deleteManyReturns struct {
		result1 *mongo.DeleteResult
		result2 error
	}
	deleteManyReturnsOnCall map[int]struct {
		result1 *mongo.DeleteResult
		result2 error
	}
	DeleteOneStub        func(context.Context, interface{}, ...*mongo.DeleteOptions) (*mongo.DeleteResult, error)
	deleteOneMutex       sync.RWMutex
	deleteOneArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 []*mongo.DeleteOptions
	}
	deleteOneReturns struct {
		result1 *mongo.DeleteResult
		result2 error
	}
	deleteOneReturnsOnCall map[int]struct {
		result1 *mongo.DeleteResult
		result2 error
	}
	FindStub        func(context.Context, interface{}, interface{}, ...*mongo.FindOptions) (mongo.Cursor, error)
	findMutex       sync.RWMutex
	findArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.FindOptions
	}
	findReturns struct {
		result1 mongo.Cursor
		result2 error
	}
	findReturnsOnCall map[int]struct {
		result1 mongo.Cursor
		result2 error
	}
	FindOneStub        func(context.Context, interface{}, interface{}, ...*mongo.FindOneOptions) mongo.SingleResult
	findOneMutex       sync.RWMutex
	findOneArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.FindOneOptions
	}
	findOneReturns struct {
		result1 mongo.SingleResult
	}
	findOneReturnsOnCall map[int]struct {
		result1 mongo.SingleResult
	}
	FindOneAndDeleteStub        func(context.Context, interface{}, interface{}, ...*mongo.FindOneAndDeleteOptions) mongo.SingleResult
	findOneAndDeleteMutex       sync.RWMutex
	findOneAndDeleteArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.FindOneAndDeleteOptions
	}
	findOneAndDeleteReturns struct {
		result1 mongo.SingleResult
	}
	findOneAndDeleteReturnsOnCall map[int]struct {
		result1 mongo.SingleResult
	}
	FindOneAndReplaceStub        func(context.Context, interface{}, interface{}, interface{}, ...*mongo.FindOneAndReplaceOptions) mongo.SingleResult
	findOneAndReplaceMutex       sync.RWMutex
	findOneAndReplaceArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 interface{}
		arg5 []*mongo.FindOneAndReplaceOptions
	}
	findOneAndReplaceReturns struct {
		result1 mongo.SingleResult
	}
	findOneAndReplaceReturnsOnCall map[int]struct {
		result1 mongo.SingleResult
	}
	FindOneAndUpdateStub        func(context.Context, interface{}, interface{}, interface{}, ...*mongo.FindOneAndUpdateOptions) mongo.SingleResult
	findOneAndUpdateMutex       sync.RWMutex
	findOneAndUpdateArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 interface{}
		arg5 []*mongo.FindOneAndUpdateOptions
	}
	findOneAndUpdateReturns struct {
		result1 mongo.SingleResult
	}
	findOneAndUpdateReturnsOnCall map[int]struct {
		result1 mongo.SingleResult
	}
	InsertManyStub        func(context.Context, []interface{}, ...*mongo.InsertManyOptions) (*mongo.InsertManyResult, error)
	insertManyMutex       sync.RWMutex
	insertManyArgsForCall []struct {
		arg1 context.Context
		arg2 []interface{}
		arg3 []*mongo.InsertManyOptions
	}
	insertManyReturns struct {
		result1 *mongo.InsertManyResult
		result2 error
	}
	insertManyReturnsOnCall map[int]struct {
		result1 *mongo.InsertManyResult
		result2 error
	}
	InsertOneStub        func(context.Context, interface{}, ...*mongo.InsertOneOptions) (*mongo.InsertOneResult, error)
	insertOneMutex       sync.RWMutex
	insertOneArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 []*mongo.InsertOneOptions
	}
	insertOneReturns struct {
		result1 *mongo.InsertOneResult
		result2 error
	}
	insertOneReturnsOnCall map[int]struct {
		result1 *mongo.InsertOneResult
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	ReplaceOneStub        func(context.Context, interface{}, interface{}, ...*mongo.ReplaceOptions) (*mongo.UpdateResult, error)
	replaceOneMutex       sync.RWMutex
	replaceOneArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.ReplaceOptions
	}
	replaceOneReturns struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	replaceOneReturnsOnCall map[int]struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	UpdateByIDStub        func(context.Context, interface{}, interface{}, ...*mongo.UpdateOptions) (*mongo.UpdateResult, error)
	updateByIDMutex       sync.RWMutex
	updateByIDArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.UpdateOptions
	}
	updateByIDReturns struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	updateByIDReturnsOnCall map[int]struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	UpdateManyStub        func(context.Context, interface{}, interface{}, ...*mongo.UpdateOptions) (*mongo.UpdateResult, error)
	updateManyMutex       sync.RWMutex
	updateManyArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.UpdateOptions
	}
	updateManyReturns struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	updateManyReturnsOnCall map[int]struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	UpdateOneStub        func(context.Context, interface{}, interface{}, ...*mongo.UpdateOptions) (*mongo.UpdateResult, error)
	updateOneMutex       sync.RWMutex
	updateOneArgsForCall []struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.UpdateOptions
	}
	updateOneReturns struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	updateOneReturnsOnCall map[int]struct {
		result1 *mongo.UpdateResult
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCollection) BulkWrite(arg1 context.Context, arg2 []mongo.WriteModel, arg3 ...*mongo.BulkWriteOptions) (*mongo.BulkWriteResult, error) {
	var arg2Copy []mongo.WriteModel
	if arg2 != nil {
		arg2Copy = make([]mongo.WriteModel, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.bulkWriteMutex.Lock()
	ret, specificReturn := fake.bulkWriteReturnsOnCall[len(fake.bulkWriteArgsForCall)]
	fake.bulkWriteArgsForCall = append(fake.bulkWriteArgsForCall, struct {
		arg1 context.Context
		arg2 []mongo.WriteModel
		arg3 []*mongo.BulkWriteOptions
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("BulkWrite", []interface{}{arg1, arg2Copy, arg3})
	fake.bulkWriteMutex.Unlock()
	if fake.BulkWriteStub != nil {
		return fake.BulkWriteStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.bulkWriteReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) BulkWriteCallCount() int {
	fake.bulkWriteMutex.RLock()
	defer fake.bulkWriteMutex.RUnlock()
	return len(fake.bulkWriteArgsForCall)
}

func (fake *FakeCollection) BulkWriteCalls(stub func(context.Context, []mongo.WriteModel, ...*mongo.BulkWriteOptions) (*mongo.BulkWriteResult, error)) {
	fake.bulkWriteMutex.Lock()
	defer fake.bulkWriteMutex.Unlock()
	fake.BulkWriteStub = stub
}

func (fake *FakeCollection) BulkWriteArgsForCall(i int) (context.Context, []mongo.WriteModel, []*mongo.BulkWriteOptions) {
	fake.bulkWriteMutex.RLock()
	defer fake.bulkWriteMutex.RUnlock()
	argsForCall := fake.bulkWriteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollection) BulkWriteReturns(result1 *mongo.BulkWriteResult, result2 error) {
	fake.bulkWriteMutex.Lock()
	defer fake.bulkWriteMutex.Unlock()
	fake.BulkWriteStub = nil
	fake.bulkWriteReturns = struct {
		result1 *mongo.BulkWriteResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) BulkWriteReturnsOnCall(i int, result1 *mongo.BulkWriteResult, result2 error) {
	fake.bulkWriteMutex.Lock()
	defer fake.bulkWriteMutex.Unlock()
	fake.BulkWriteStub = nil
	if fake.bulkWriteReturnsOnCall == nil {
		fake.bulkWriteReturnsOnCall = make(map[int]struct {
			result1 *mongo.BulkWriteResult
			result2 error
		})
	}
	fake.bulkWriteReturnsOnCall[i] = struct {
		result1 *mongo.BulkWriteResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) Clone(arg1 ...*mongo.CollectionOptions) (mongo.Collection, error) {
	fake.cloneMutex.Lock()
	ret, specificReturn := fake.cloneReturnsOnCall[len(fake.cloneArgsForCall)]
	fake.cloneArgsForCall = append(fake.cloneArgsForCall, struct {
		arg1 []*mongo.CollectionOptions
	}{arg1})
	fake.recordInvocation("Clone", []interface{}{arg1})
	fake.cloneMutex.Unlock()
	if fake.CloneStub != nil {
		return fake.CloneStub(arg1...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.cloneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) CloneCallCount() int {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	return len(fake.cloneArgsForCall)
}

func (fake *FakeCollection) CloneCalls(stub func(...*mongo.CollectionOptions) (mongo.Collection, error)) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = stub
}

func (fake *FakeCollection) CloneArgsForCall(i int) []*mongo.CollectionOptions {
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	argsForCall := fake.cloneArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCollection) CloneReturns(result1 mongo.Collection, result2 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	fake.cloneReturns = struct {
		result1 mongo.Collection
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) CloneReturnsOnCall(i int, result1 mongo.Collection, result2 error) {
	fake.cloneMutex.Lock()
	defer fake.cloneMutex.Unlock()
	fake.CloneStub = nil
	if fake.cloneReturnsOnCall == nil {
		fake.cloneReturnsOnCall = make(map[int]struct {
			result1 mongo.Collection
			result2 error
		})
	}
	fake.cloneReturnsOnCall[i] = struct {
		result1 mongo.Collection
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) Database() mongo.Database {
	fake.databaseMutex.Lock()
	ret, specificReturn := fake.databaseReturnsOnCall[len(fake.databaseArgsForCall)]
	fake.databaseArgsForCall = append(fake.databaseArgsForCall, struct {
	}{})
	fake.recordInvocation("Database", []interface{}{})
	fake.databaseMutex.Unlock()
	if fake.DatabaseStub != nil {
		return fake.DatabaseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.databaseReturns
	return fakeReturns.result1
}

func (fake *FakeCollection) DatabaseCallCount() int {
	fake.databaseMutex.RLock()
	defer fake.databaseMutex.RUnlock()
	return len(fake.databaseArgsForCall)
}

func (fake *FakeCollection) DatabaseCalls(stub func() mongo.Database) {
	fake.databaseMutex.Lock()
	defer fake.databaseMutex.Unlock()
	fake.DatabaseStub = stub
}

func (fake *FakeCollection) DatabaseReturns(result1 mongo.Database) {
	fake.databaseMutex.Lock()
	defer fake.databaseMutex.Unlock()
	fake.DatabaseStub = nil
	fake.databaseReturns = struct {
		result1 mongo.Database
	}{result1}
}

func (fake *FakeCollection) DatabaseReturnsOnCall(i int, result1 mongo.Database) {
	fake.databaseMutex.Lock()
	defer fake.databaseMutex.Unlock()
	fake.DatabaseStub = nil
	if fake.databaseReturnsOnCall == nil {
		fake.databaseReturnsOnCall = make(map[int]struct {
			result1 mongo.Database
		})
	}
	fake.databaseReturnsOnCall[i] = struct {
		result1 mongo.Database
	}{result1}
}

func (fake *FakeCollection) DeleteMany(arg1 context.Context, arg2 interface{}, arg3 ...*mongo.DeleteOptions) (*mongo.DeleteResult, error) {
	fake.deleteManyMutex.Lock()
	ret, specificReturn := fake.deleteManyReturnsOnCall[len(fake.deleteManyArgsForCall)]
	fake.deleteManyArgsForCall = append(fake.deleteManyArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 []*mongo.DeleteOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteMany", []interface{}{arg1, arg2, arg3})
	fake.deleteManyMutex.Unlock()
	if fake.DeleteManyStub != nil {
		return fake.DeleteManyStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteManyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) DeleteManyCallCount() int {
	fake.deleteManyMutex.RLock()
	defer fake.deleteManyMutex.RUnlock()
	return len(fake.deleteManyArgsForCall)
}

func (fake *FakeCollection) DeleteManyCalls(stub func(context.Context, interface{}, ...*mongo.DeleteOptions) (*mongo.DeleteResult, error)) {
	fake.deleteManyMutex.Lock()
	defer fake.deleteManyMutex.Unlock()
	fake.DeleteManyStub = stub
}

func (fake *FakeCollection) DeleteManyArgsForCall(i int) (context.Context, interface{}, []*mongo.DeleteOptions) {
	fake.deleteManyMutex.RLock()
	defer fake.deleteManyMutex.RUnlock()
	argsForCall := fake.deleteManyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollection) DeleteManyReturns(result1 *mongo.DeleteResult, result2 error) {
	fake.deleteManyMutex.Lock()
	defer fake.deleteManyMutex.Unlock()
	fake.DeleteManyStub = nil
	fake.deleteManyReturns = struct {
		result1 *mongo.DeleteResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) DeleteManyReturnsOnCall(i int, result1 *mongo.DeleteResult, result2 error) {
	fake.deleteManyMutex.Lock()
	defer fake.deleteManyMutex.Unlock()
	fake.DeleteManyStub = nil
	if fake.deleteManyReturnsOnCall == nil {
		fake.deleteManyReturnsOnCall = make(map[int]struct {
			result1 *mongo.DeleteResult
			result2 error
		})
	}
	fake.deleteManyReturnsOnCall[i] = struct {
		result1 *mongo.DeleteResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) DeleteOne(arg1 context.Context, arg2 interface{}, arg3 ...*mongo.DeleteOptions) (*mongo.DeleteResult, error) {
	fake.deleteOneMutex.Lock()
	ret, specificReturn := fake.deleteOneReturnsOnCall[len(fake.deleteOneArgsForCall)]
	fake.deleteOneArgsForCall = append(fake.deleteOneArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 []*mongo.DeleteOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("DeleteOne", []interface{}{arg1, arg2, arg3})
	fake.deleteOneMutex.Unlock()
	if fake.DeleteOneStub != nil {
		return fake.DeleteOneStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteOneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) DeleteOneCallCount() int {
	fake.deleteOneMutex.RLock()
	defer fake.deleteOneMutex.RUnlock()
	return len(fake.deleteOneArgsForCall)
}

func (fake *FakeCollection) DeleteOneCalls(stub func(context.Context, interface{}, ...*mongo.DeleteOptions) (*mongo.DeleteResult, error)) {
	fake.deleteOneMutex.Lock()
	defer fake.deleteOneMutex.Unlock()
	fake.DeleteOneStub = stub
}

func (fake *FakeCollection) DeleteOneArgsForCall(i int) (context.Context, interface{}, []*mongo.DeleteOptions) {
	fake.deleteOneMutex.RLock()
	defer fake.deleteOneMutex.RUnlock()
	argsForCall := fake.deleteOneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollection) DeleteOneReturns(result1 *mongo.DeleteResult, result2 error) {
	fake.deleteOneMutex.Lock()
	defer fake.deleteOneMutex.Unlock()
	fake.DeleteOneStub = nil
	fake.deleteOneReturns = struct {
		result1 *mongo.DeleteResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) DeleteOneReturnsOnCall(i int, result1 *mongo.DeleteResult, result2 error) {
	fake.deleteOneMutex.Lock()
	defer fake.deleteOneMutex.Unlock()
	fake.DeleteOneStub = nil
	if fake.deleteOneReturnsOnCall == nil {
		fake.deleteOneReturnsOnCall = make(map[int]struct {
			result1 *mongo.DeleteResult
			result2 error
		})
	}
	fake.deleteOneReturnsOnCall[i] = struct {
		result1 *mongo.DeleteResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) Find(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 ...*mongo.FindOptions) (mongo.Cursor, error) {
	fake.findMutex.Lock()
	ret, specificReturn := fake.findReturnsOnCall[len(fake.findArgsForCall)]
	fake.findArgsForCall = append(fake.findArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.FindOptions
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("Find", []interface{}{arg1, arg2, arg3, arg4})
	fake.findMutex.Unlock()
	if fake.FindStub != nil {
		return fake.FindStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.findReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) FindCallCount() int {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	return len(fake.findArgsForCall)
}

func (fake *FakeCollection) FindCalls(stub func(context.Context, interface{}, interface{}, ...*mongo.FindOptions) (mongo.Cursor, error)) {
	fake.findMutex.Lock()
	defer fake.findMutex.Unlock()
	fake.FindStub = stub
}

func (fake *FakeCollection) FindArgsForCall(i int) (context.Context, interface{}, interface{}, []*mongo.FindOptions) {
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	argsForCall := fake.findArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCollection) FindReturns(result1 mongo.Cursor, result2 error) {
	fake.findMutex.Lock()
	defer fake.findMutex.Unlock()
	fake.FindStub = nil
	fake.findReturns = struct {
		result1 mongo.Cursor
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) FindReturnsOnCall(i int, result1 mongo.Cursor, result2 error) {
	fake.findMutex.Lock()
	defer fake.findMutex.Unlock()
	fake.FindStub = nil
	if fake.findReturnsOnCall == nil {
		fake.findReturnsOnCall = make(map[int]struct {
			result1 mongo.Cursor
			result2 error
		})
	}
	fake.findReturnsOnCall[i] = struct {
		result1 mongo.Cursor
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) FindOne(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 ...*mongo.FindOneOptions) mongo.SingleResult {
	fake.findOneMutex.Lock()
	ret, specificReturn := fake.findOneReturnsOnCall[len(fake.findOneArgsForCall)]
	fake.findOneArgsForCall = append(fake.findOneArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.FindOneOptions
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("FindOne", []interface{}{arg1, arg2, arg3, arg4})
	fake.findOneMutex.Unlock()
	if fake.FindOneStub != nil {
		return fake.FindOneStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.findOneReturns
	return fakeReturns.result1
}

func (fake *FakeCollection) FindOneCallCount() int {
	fake.findOneMutex.RLock()
	defer fake.findOneMutex.RUnlock()
	return len(fake.findOneArgsForCall)
}

func (fake *FakeCollection) FindOneCalls(stub func(context.Context, interface{}, interface{}, ...*mongo.FindOneOptions) mongo.SingleResult) {
	fake.findOneMutex.Lock()
	defer fake.findOneMutex.Unlock()
	fake.FindOneStub = stub
}

func (fake *FakeCollection) FindOneArgsForCall(i int) (context.Context, interface{}, interface{}, []*mongo.FindOneOptions) {
	fake.findOneMutex.RLock()
	defer fake.findOneMutex.RUnlock()
	argsForCall := fake.findOneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCollection) FindOneReturns(result1 mongo.SingleResult) {
	fake.findOneMutex.Lock()
	defer fake.findOneMutex.Unlock()
	fake.FindOneStub = nil
	fake.findOneReturns = struct {
		result1 mongo.SingleResult
	}{result1}
}

func (fake *FakeCollection) FindOneReturnsOnCall(i int, result1 mongo.SingleResult) {
	fake.findOneMutex.Lock()
	defer fake.findOneMutex.Unlock()
	fake.FindOneStub = nil
	if fake.findOneReturnsOnCall == nil {
		fake.findOneReturnsOnCall = make(map[int]struct {
			result1 mongo.SingleResult
		})
	}
	fake.findOneReturnsOnCall[i] = struct {
		result1 mongo.SingleResult
	}{result1}
}

func (fake *FakeCollection) FindOneAndDelete(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 ...*mongo.FindOneAndDeleteOptions) mongo.SingleResult {
	fake.findOneAndDeleteMutex.Lock()
	ret, specificReturn := fake.findOneAndDeleteReturnsOnCall[len(fake.findOneAndDeleteArgsForCall)]
	fake.findOneAndDeleteArgsForCall = append(fake.findOneAndDeleteArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.FindOneAndDeleteOptions
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("FindOneAndDelete", []interface{}{arg1, arg2, arg3, arg4})
	fake.findOneAndDeleteMutex.Unlock()
	if fake.FindOneAndDeleteStub != nil {
		return fake.FindOneAndDeleteStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.findOneAndDeleteReturns
	return fakeReturns.result1
}

func (fake *FakeCollection) FindOneAndDeleteCallCount() int {
	fake.findOneAndDeleteMutex.RLock()
	defer fake.findOneAndDeleteMutex.RUnlock()
	return len(fake.findOneAndDeleteArgsForCall)
}

func (fake *FakeCollection) FindOneAndDeleteCalls(stub func(context.Context, interface{}, interface{}, ...*mongo.FindOneAndDeleteOptions) mongo.SingleResult) {
	fake.findOneAndDeleteMutex.Lock()
	defer fake.findOneAndDeleteMutex.Unlock()
	fake.FindOneAndDeleteStub = stub
}

func (fake *FakeCollection) FindOneAndDeleteArgsForCall(i int) (context.Context, interface{}, interface{}, []*mongo.FindOneAndDeleteOptions) {
	fake.findOneAndDeleteMutex.RLock()
	defer fake.findOneAndDeleteMutex.RUnlock()
	argsForCall := fake.findOneAndDeleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCollection) FindOneAndDeleteReturns(result1 mongo.SingleResult) {
	fake.findOneAndDeleteMutex.Lock()
	defer fake.findOneAndDeleteMutex.Unlock()
	fake.FindOneAndDeleteStub = nil
	fake.findOneAndDeleteReturns = struct {
		result1 mongo.SingleResult
	}{result1}
}

func (fake *FakeCollection) FindOneAndDeleteReturnsOnCall(i int, result1 mongo.SingleResult) {
	fake.findOneAndDeleteMutex.Lock()
	defer fake.findOneAndDeleteMutex.Unlock()
	fake.FindOneAndDeleteStub = nil
	if fake.findOneAndDeleteReturnsOnCall == nil {
		fake.findOneAndDeleteReturnsOnCall = make(map[int]struct {
			result1 mongo.SingleResult
		})
	}
	fake.findOneAndDeleteReturnsOnCall[i] = struct {
		result1 mongo.SingleResult
	}{result1}
}

func (fake *FakeCollection) FindOneAndReplace(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 interface{}, arg5 ...*mongo.FindOneAndReplaceOptions) mongo.SingleResult {
	fake.findOneAndReplaceMutex.Lock()
	ret, specificReturn := fake.findOneAndReplaceReturnsOnCall[len(fake.findOneAndReplaceArgsForCall)]
	fake.findOneAndReplaceArgsForCall = append(fake.findOneAndReplaceArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 interface{}
		arg5 []*mongo.FindOneAndReplaceOptions
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("FindOneAndReplace", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.findOneAndReplaceMutex.Unlock()
	if fake.FindOneAndReplaceStub != nil {
		return fake.FindOneAndReplaceStub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.findOneAndReplaceReturns
	return fakeReturns.result1
}

func (fake *FakeCollection) FindOneAndReplaceCallCount() int {
	fake.findOneAndReplaceMutex.RLock()
	defer fake.findOneAndReplaceMutex.RUnlock()
	return len(fake.findOneAndReplaceArgsForCall)
}

func (fake *FakeCollection) FindOneAndReplaceCalls(stub func(context.Context, interface{}, interface{}, interface{}, ...*mongo.FindOneAndReplaceOptions) mongo.SingleResult) {
	fake.findOneAndReplaceMutex.Lock()
	defer fake.findOneAndReplaceMutex.Unlock()
	fake.FindOneAndReplaceStub = stub
}

func (fake *FakeCollection) FindOneAndReplaceArgsForCall(i int) (context.Context, interface{}, interface{}, interface{}, []*mongo.FindOneAndReplaceOptions) {
	fake.findOneAndReplaceMutex.RLock()
	defer fake.findOneAndReplaceMutex.RUnlock()
	argsForCall := fake.findOneAndReplaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeCollection) FindOneAndReplaceReturns(result1 mongo.SingleResult) {
	fake.findOneAndReplaceMutex.Lock()
	defer fake.findOneAndReplaceMutex.Unlock()
	fake.FindOneAndReplaceStub = nil
	fake.findOneAndReplaceReturns = struct {
		result1 mongo.SingleResult
	}{result1}
}

func (fake *FakeCollection) FindOneAndReplaceReturnsOnCall(i int, result1 mongo.SingleResult) {
	fake.findOneAndReplaceMutex.Lock()
	defer fake.findOneAndReplaceMutex.Unlock()
	fake.FindOneAndReplaceStub = nil
	if fake.findOneAndReplaceReturnsOnCall == nil {
		fake.findOneAndReplaceReturnsOnCall = make(map[int]struct {
			result1 mongo.SingleResult
		})
	}
	fake.findOneAndReplaceReturnsOnCall[i] = struct {
		result1 mongo.SingleResult
	}{result1}
}

func (fake *FakeCollection) FindOneAndUpdate(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 interface{}, arg5 ...*mongo.FindOneAndUpdateOptions) mongo.SingleResult {
	fake.findOneAndUpdateMutex.Lock()
	ret, specificReturn := fake.findOneAndUpdateReturnsOnCall[len(fake.findOneAndUpdateArgsForCall)]
	fake.findOneAndUpdateArgsForCall = append(fake.findOneAndUpdateArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 interface{}
		arg5 []*mongo.FindOneAndUpdateOptions
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("FindOneAndUpdate", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.findOneAndUpdateMutex.Unlock()
	if fake.FindOneAndUpdateStub != nil {
		return fake.FindOneAndUpdateStub(arg1, arg2, arg3, arg4, arg5...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.findOneAndUpdateReturns
	return fakeReturns.result1
}

func (fake *FakeCollection) FindOneAndUpdateCallCount() int {
	fake.findOneAndUpdateMutex.RLock()
	defer fake.findOneAndUpdateMutex.RUnlock()
	return len(fake.findOneAndUpdateArgsForCall)
}

func (fake *FakeCollection) FindOneAndUpdateCalls(stub func(context.Context, interface{}, interface{}, interface{}, ...*mongo.FindOneAndUpdateOptions) mongo.SingleResult) {
	fake.findOneAndUpdateMutex.Lock()
	defer fake.findOneAndUpdateMutex.Unlock()
	fake.FindOneAndUpdateStub = stub
}

func (fake *FakeCollection) FindOneAndUpdateArgsForCall(i int) (context.Context, interface{}, interface{}, interface{}, []*mongo.FindOneAndUpdateOptions) {
	fake.findOneAndUpdateMutex.RLock()
	defer fake.findOneAndUpdateMutex.RUnlock()
	argsForCall := fake.findOneAndUpdateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeCollection) FindOneAndUpdateReturns(result1 mongo.SingleResult) {
	fake.findOneAndUpdateMutex.Lock()
	defer fake.findOneAndUpdateMutex.Unlock()
	fake.FindOneAndUpdateStub = nil
	fake.findOneAndUpdateReturns = struct {
		result1 mongo.SingleResult
	}{result1}
}

func (fake *FakeCollection) FindOneAndUpdateReturnsOnCall(i int, result1 mongo.SingleResult) {
	fake.findOneAndUpdateMutex.Lock()
	defer fake.findOneAndUpdateMutex.Unlock()
	fake.FindOneAndUpdateStub = nil
	if fake.findOneAndUpdateReturnsOnCall == nil {
		fake.findOneAndUpdateReturnsOnCall = make(map[int]struct {
			result1 mongo.SingleResult
		})
	}
	fake.findOneAndUpdateReturnsOnCall[i] = struct {
		result1 mongo.SingleResult
	}{result1}
}

func (fake *FakeCollection) InsertMany(arg1 context.Context, arg2 []interface{}, arg3 ...*mongo.InsertManyOptions) (*mongo.InsertManyResult, error) {
	var arg2Copy []interface{}
	if arg2 != nil {
		arg2Copy = make([]interface{}, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.insertManyMutex.Lock()
	ret, specificReturn := fake.insertManyReturnsOnCall[len(fake.insertManyArgsForCall)]
	fake.insertManyArgsForCall = append(fake.insertManyArgsForCall, struct {
		arg1 context.Context
		arg2 []interface{}
		arg3 []*mongo.InsertManyOptions
	}{arg1, arg2Copy, arg3})
	fake.recordInvocation("InsertMany", []interface{}{arg1, arg2Copy, arg3})
	fake.insertManyMutex.Unlock()
	if fake.InsertManyStub != nil {
		return fake.InsertManyStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.insertManyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) InsertManyCallCount() int {
	fake.insertManyMutex.RLock()
	defer fake.insertManyMutex.RUnlock()
	return len(fake.insertManyArgsForCall)
}

func (fake *FakeCollection) InsertManyCalls(stub func(context.Context, []interface{}, ...*mongo.InsertManyOptions) (*mongo.InsertManyResult, error)) {
	fake.insertManyMutex.Lock()
	defer fake.insertManyMutex.Unlock()
	fake.InsertManyStub = stub
}

func (fake *FakeCollection) InsertManyArgsForCall(i int) (context.Context, []interface{}, []*mongo.InsertManyOptions) {
	fake.insertManyMutex.RLock()
	defer fake.insertManyMutex.RUnlock()
	argsForCall := fake.insertManyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollection) InsertManyReturns(result1 *mongo.InsertManyResult, result2 error) {
	fake.insertManyMutex.Lock()
	defer fake.insertManyMutex.Unlock()
	fake.InsertManyStub = nil
	fake.insertManyReturns = struct {
		result1 *mongo.InsertManyResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) InsertManyReturnsOnCall(i int, result1 *mongo.InsertManyResult, result2 error) {
	fake.insertManyMutex.Lock()
	defer fake.insertManyMutex.Unlock()
	fake.InsertManyStub = nil
	if fake.insertManyReturnsOnCall == nil {
		fake.insertManyReturnsOnCall = make(map[int]struct {
			result1 *mongo.InsertManyResult
			result2 error
		})
	}
	fake.insertManyReturnsOnCall[i] = struct {
		result1 *mongo.InsertManyResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) InsertOne(arg1 context.Context, arg2 interface{}, arg3 ...*mongo.InsertOneOptions) (*mongo.InsertOneResult, error) {
	fake.insertOneMutex.Lock()
	ret, specificReturn := fake.insertOneReturnsOnCall[len(fake.insertOneArgsForCall)]
	fake.insertOneArgsForCall = append(fake.insertOneArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 []*mongo.InsertOneOptions
	}{arg1, arg2, arg3})
	fake.recordInvocation("InsertOne", []interface{}{arg1, arg2, arg3})
	fake.insertOneMutex.Unlock()
	if fake.InsertOneStub != nil {
		return fake.InsertOneStub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.insertOneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) InsertOneCallCount() int {
	fake.insertOneMutex.RLock()
	defer fake.insertOneMutex.RUnlock()
	return len(fake.insertOneArgsForCall)
}

func (fake *FakeCollection) InsertOneCalls(stub func(context.Context, interface{}, ...*mongo.InsertOneOptions) (*mongo.InsertOneResult, error)) {
	fake.insertOneMutex.Lock()
	defer fake.insertOneMutex.Unlock()
	fake.InsertOneStub = stub
}

func (fake *FakeCollection) InsertOneArgsForCall(i int) (context.Context, interface{}, []*mongo.InsertOneOptions) {
	fake.insertOneMutex.RLock()
	defer fake.insertOneMutex.RUnlock()
	argsForCall := fake.insertOneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeCollection) InsertOneReturns(result1 *mongo.InsertOneResult, result2 error) {
	fake.insertOneMutex.Lock()
	defer fake.insertOneMutex.Unlock()
	fake.InsertOneStub = nil
	fake.insertOneReturns = struct {
		result1 *mongo.InsertOneResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) InsertOneReturnsOnCall(i int, result1 *mongo.InsertOneResult, result2 error) {
	fake.insertOneMutex.Lock()
	defer fake.insertOneMutex.Unlock()
	fake.InsertOneStub = nil
	if fake.insertOneReturnsOnCall == nil {
		fake.insertOneReturnsOnCall = make(map[int]struct {
			result1 *mongo.InsertOneResult
			result2 error
		})
	}
	fake.insertOneReturnsOnCall[i] = struct {
		result1 *mongo.InsertOneResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakeCollection) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeCollection) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakeCollection) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeCollection) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeCollection) ReplaceOne(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 ...*mongo.ReplaceOptions) (*mongo.UpdateResult, error) {
	fake.replaceOneMutex.Lock()
	ret, specificReturn := fake.replaceOneReturnsOnCall[len(fake.replaceOneArgsForCall)]
	fake.replaceOneArgsForCall = append(fake.replaceOneArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.ReplaceOptions
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("ReplaceOne", []interface{}{arg1, arg2, arg3, arg4})
	fake.replaceOneMutex.Unlock()
	if fake.ReplaceOneStub != nil {
		return fake.ReplaceOneStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.replaceOneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) ReplaceOneCallCount() int {
	fake.replaceOneMutex.RLock()
	defer fake.replaceOneMutex.RUnlock()
	return len(fake.replaceOneArgsForCall)
}

func (fake *FakeCollection) ReplaceOneCalls(stub func(context.Context, interface{}, interface{}, ...*mongo.ReplaceOptions) (*mongo.UpdateResult, error)) {
	fake.replaceOneMutex.Lock()
	defer fake.replaceOneMutex.Unlock()
	fake.ReplaceOneStub = stub
}

func (fake *FakeCollection) ReplaceOneArgsForCall(i int) (context.Context, interface{}, interface{}, []*mongo.ReplaceOptions) {
	fake.replaceOneMutex.RLock()
	defer fake.replaceOneMutex.RUnlock()
	argsForCall := fake.replaceOneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCollection) ReplaceOneReturns(result1 *mongo.UpdateResult, result2 error) {
	fake.replaceOneMutex.Lock()
	defer fake.replaceOneMutex.Unlock()
	fake.ReplaceOneStub = nil
	fake.replaceOneReturns = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) ReplaceOneReturnsOnCall(i int, result1 *mongo.UpdateResult, result2 error) {
	fake.replaceOneMutex.Lock()
	defer fake.replaceOneMutex.Unlock()
	fake.ReplaceOneStub = nil
	if fake.replaceOneReturnsOnCall == nil {
		fake.replaceOneReturnsOnCall = make(map[int]struct {
			result1 *mongo.UpdateResult
			result2 error
		})
	}
	fake.replaceOneReturnsOnCall[i] = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) UpdateByID(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 ...*mongo.UpdateOptions) (*mongo.UpdateResult, error) {
	fake.updateByIDMutex.Lock()
	ret, specificReturn := fake.updateByIDReturnsOnCall[len(fake.updateByIDArgsForCall)]
	fake.updateByIDArgsForCall = append(fake.updateByIDArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.UpdateOptions
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UpdateByID", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateByIDMutex.Unlock()
	if fake.UpdateByIDStub != nil {
		return fake.UpdateByIDStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateByIDReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) UpdateByIDCallCount() int {
	fake.updateByIDMutex.RLock()
	defer fake.updateByIDMutex.RUnlock()
	return len(fake.updateByIDArgsForCall)
}

func (fake *FakeCollection) UpdateByIDCalls(stub func(context.Context, interface{}, interface{}, ...*mongo.UpdateOptions) (*mongo.UpdateResult, error)) {
	fake.updateByIDMutex.Lock()
	defer fake.updateByIDMutex.Unlock()
	fake.UpdateByIDStub = stub
}

func (fake *FakeCollection) UpdateByIDArgsForCall(i int) (context.Context, interface{}, interface{}, []*mongo.UpdateOptions) {
	fake.updateByIDMutex.RLock()
	defer fake.updateByIDMutex.RUnlock()
	argsForCall := fake.updateByIDArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCollection) UpdateByIDReturns(result1 *mongo.UpdateResult, result2 error) {
	fake.updateByIDMutex.Lock()
	defer fake.updateByIDMutex.Unlock()
	fake.UpdateByIDStub = nil
	fake.updateByIDReturns = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) UpdateByIDReturnsOnCall(i int, result1 *mongo.UpdateResult, result2 error) {
	fake.updateByIDMutex.Lock()
	defer fake.updateByIDMutex.Unlock()
	fake.UpdateByIDStub = nil
	if fake.updateByIDReturnsOnCall == nil {
		fake.updateByIDReturnsOnCall = make(map[int]struct {
			result1 *mongo.UpdateResult
			result2 error
		})
	}
	fake.updateByIDReturnsOnCall[i] = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) UpdateMany(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 ...*mongo.UpdateOptions) (*mongo.UpdateResult, error) {
	fake.updateManyMutex.Lock()
	ret, specificReturn := fake.updateManyReturnsOnCall[len(fake.updateManyArgsForCall)]
	fake.updateManyArgsForCall = append(fake.updateManyArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.UpdateOptions
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UpdateMany", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateManyMutex.Unlock()
	if fake.UpdateManyStub != nil {
		return fake.UpdateManyStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateManyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) UpdateManyCallCount() int {
	fake.updateManyMutex.RLock()
	defer fake.updateManyMutex.RUnlock()
	return len(fake.updateManyArgsForCall)
}

func (fake *FakeCollection) UpdateManyCalls(stub func(context.Context, interface{}, interface{}, ...*mongo.UpdateOptions) (*mongo.UpdateResult, error)) {
	fake.updateManyMutex.Lock()
	defer fake.updateManyMutex.Unlock()
	fake.UpdateManyStub = stub
}

func (fake *FakeCollection) UpdateManyArgsForCall(i int) (context.Context, interface{}, interface{}, []*mongo.UpdateOptions) {
	fake.updateManyMutex.RLock()
	defer fake.updateManyMutex.RUnlock()
	argsForCall := fake.updateManyArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCollection) UpdateManyReturns(result1 *mongo.UpdateResult, result2 error) {
	fake.updateManyMutex.Lock()
	defer fake.updateManyMutex.Unlock()
	fake.UpdateManyStub = nil
	fake.updateManyReturns = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) UpdateManyReturnsOnCall(i int, result1 *mongo.UpdateResult, result2 error) {
	fake.updateManyMutex.Lock()
	defer fake.updateManyMutex.Unlock()
	fake.UpdateManyStub = nil
	if fake.updateManyReturnsOnCall == nil {
		fake.updateManyReturnsOnCall = make(map[int]struct {
			result1 *mongo.UpdateResult
			result2 error
		})
	}
	fake.updateManyReturnsOnCall[i] = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) UpdateOne(arg1 context.Context, arg2 interface{}, arg3 interface{}, arg4 ...*mongo.UpdateOptions) (*mongo.UpdateResult, error) {
	fake.updateOneMutex.Lock()
	ret, specificReturn := fake.updateOneReturnsOnCall[len(fake.updateOneArgsForCall)]
	fake.updateOneArgsForCall = append(fake.updateOneArgsForCall, struct {
		arg1 context.Context
		arg2 interface{}
		arg3 interface{}
		arg4 []*mongo.UpdateOptions
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("UpdateOne", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateOneMutex.Unlock()
	if fake.UpdateOneStub != nil {
		return fake.UpdateOneStub(arg1, arg2, arg3, arg4...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateOneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCollection) UpdateOneCallCount() int {
	fake.updateOneMutex.RLock()
	defer fake.updateOneMutex.RUnlock()
	return len(fake.updateOneArgsForCall)
}

func (fake *FakeCollection) UpdateOneCalls(stub func(context.Context, interface{}, interface{}, ...*mongo.UpdateOptions) (*mongo.UpdateResult, error)) {
	fake.updateOneMutex.Lock()
	defer fake.updateOneMutex.Unlock()
	fake.UpdateOneStub = stub
}

func (fake *FakeCollection) UpdateOneArgsForCall(i int) (context.Context, interface{}, interface{}, []*mongo.UpdateOptions) {
	fake.updateOneMutex.RLock()
	defer fake.updateOneMutex.RUnlock()
	argsForCall := fake.updateOneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeCollection) UpdateOneReturns(result1 *mongo.UpdateResult, result2 error) {
	fake.updateOneMutex.Lock()
	defer fake.updateOneMutex.Unlock()
	fake.UpdateOneStub = nil
	fake.updateOneReturns = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) UpdateOneReturnsOnCall(i int, result1 *mongo.UpdateResult, result2 error) {
	fake.updateOneMutex.Lock()
	defer fake.updateOneMutex.Unlock()
	fake.UpdateOneStub = nil
	if fake.updateOneReturnsOnCall == nil {
		fake.updateOneReturnsOnCall = make(map[int]struct {
			result1 *mongo.UpdateResult
			result2 error
		})
	}
	fake.updateOneReturnsOnCall[i] = struct {
		result1 *mongo.UpdateResult
		result2 error
	}{result1, result2}
}

func (fake *FakeCollection) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.bulkWriteMutex.RLock()
	defer fake.bulkWriteMutex.RUnlock()
	fake.cloneMutex.RLock()
	defer fake.cloneMutex.RUnlock()
	fake.databaseMutex.RLock()
	defer fake.databaseMutex.RUnlock()
	fake.deleteManyMutex.RLock()
	defer fake.deleteManyMutex.RUnlock()
	fake.deleteOneMutex.RLock()
	defer fake.deleteOneMutex.RUnlock()
	fake.findMutex.RLock()
	defer fake.findMutex.RUnlock()
	fake.findOneMutex.RLock()
	defer fake.findOneMutex.RUnlock()
	fake.findOneAndDeleteMutex.RLock()
	defer fake.findOneAndDeleteMutex.RUnlock()
	fake.findOneAndReplaceMutex.RLock()
	defer fake.findOneAndReplaceMutex.RUnlock()
	fake.findOneAndUpdateMutex.RLock()
	defer fake.findOneAndUpdateMutex.RUnlock()
	fake.insertManyMutex.RLock()
	defer fake.insertManyMutex.RUnlock()
	fake.insertOneMutex.RLock()
	defer fake.insertOneMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.replaceOneMutex.RLock()
	defer fake.replaceOneMutex.RUnlock()
	fake.updateByIDMutex.RLock()
	defer fake.updateByIDMutex.RUnlock()
	fake.updateManyMutex.RLock()
	defer fake.updateManyMutex.RUnlock()
	fake.updateOneMutex.RLock()
	defer fake.updateOneMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCollection) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ mongo.Collection = new(FakeCollection)
