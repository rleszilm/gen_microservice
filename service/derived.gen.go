// Code generated by goderive DO NOT EDIT.

package service

// deriveContains returns whether the item is contained in the list.
func deriveContains(list []string, item string) bool {
	for _, v := range list {
		if v == item {
			return true
		}
	}
	return false
}

// deriveUnionDeps returns the union of two maps, with respect to the keys.
// It does this by adding the keys to the first map.
func deriveUnionDeps(union, that map[string]struct{}) map[string]struct{} {
	for k := range that {
		union[k] = struct{}{}
	}
	return union
}

// deriveCloneDeps returns a clone of the src parameter.
func deriveCloneDeps(src map[string]map[string]struct{}) map[string]map[string]struct{} {
	if src == nil {
		return nil
	}
	dst := make(map[string]map[string]struct{})
	deriveDeepCopy(dst, src)
	return dst
}

// deriveFmapServiceNames returns a list where each element of the input list has been morphed by the input function.
func deriveFmapServiceNames(f func(Service) string, list []Service) []string {
	out := make([]string, len(list))
	for i, elem := range list {
		out[i] = f(elem)
	}
	return out
}

// deriveSetDeps returns the input list as a map with the items of the list as the keys of the map.
func deriveSetDeps(list []string) map[string]struct{} {
	set := make(map[string]struct{}, len(list))
	for _, v := range list {
		set[v] = struct{}{}
	}
	return set
}

// deriveDeepCopy recursively copies the contents of src into dst.
func deriveDeepCopy(dst, src map[string]map[string]struct{}) {
	for src_key, src_value := range src {
		if src_value == nil {
			dst[src_key] = nil
		}
		if src_value != nil {
			dst[src_key] = make(map[string]struct{}, len(src_value))
			deriveDeepCopy_(dst[src_key], src_value)
		} else {
			dst[src_key] = nil
		}
	}
}

// deriveDeepCopy_ recursively copies the contents of src into dst.
func deriveDeepCopy_(dst, src map[string]struct{}) {
	for src_key, src_value := range src {
		dst[src_key] = src_value
	}
}
