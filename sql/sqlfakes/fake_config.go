// Code generated by counterfeiter. DO NOT EDIT.
package sqlfakes

import (
	"sync"

	"github.com/rleszilm/genms/sql"
)

type FakeConfig struct {
	ConnectionStringStub        func() string
	connectionStringMutex       sync.RWMutex
	connectionStringArgsForCall []struct {
	}
	connectionStringReturns struct {
		result1 string
	}
	connectionStringReturnsOnCall map[int]struct {
		result1 string
	}
	DriverStub        func() string
	driverMutex       sync.RWMutex
	driverArgsForCall []struct {
	}
	driverReturns struct {
		result1 string
	}
	driverReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConfig) ConnectionString() string {
	fake.connectionStringMutex.Lock()
	ret, specificReturn := fake.connectionStringReturnsOnCall[len(fake.connectionStringArgsForCall)]
	fake.connectionStringArgsForCall = append(fake.connectionStringArgsForCall, struct {
	}{})
	fake.recordInvocation("ConnectionString", []interface{}{})
	fake.connectionStringMutex.Unlock()
	if fake.ConnectionStringStub != nil {
		return fake.ConnectionStringStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.connectionStringReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) ConnectionStringCallCount() int {
	fake.connectionStringMutex.RLock()
	defer fake.connectionStringMutex.RUnlock()
	return len(fake.connectionStringArgsForCall)
}

func (fake *FakeConfig) ConnectionStringCalls(stub func() string) {
	fake.connectionStringMutex.Lock()
	defer fake.connectionStringMutex.Unlock()
	fake.ConnectionStringStub = stub
}

func (fake *FakeConfig) ConnectionStringReturns(result1 string) {
	fake.connectionStringMutex.Lock()
	defer fake.connectionStringMutex.Unlock()
	fake.ConnectionStringStub = nil
	fake.connectionStringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) ConnectionStringReturnsOnCall(i int, result1 string) {
	fake.connectionStringMutex.Lock()
	defer fake.connectionStringMutex.Unlock()
	fake.ConnectionStringStub = nil
	if fake.connectionStringReturnsOnCall == nil {
		fake.connectionStringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.connectionStringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) Driver() string {
	fake.driverMutex.Lock()
	ret, specificReturn := fake.driverReturnsOnCall[len(fake.driverArgsForCall)]
	fake.driverArgsForCall = append(fake.driverArgsForCall, struct {
	}{})
	fake.recordInvocation("Driver", []interface{}{})
	fake.driverMutex.Unlock()
	if fake.DriverStub != nil {
		return fake.DriverStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.driverReturns
	return fakeReturns.result1
}

func (fake *FakeConfig) DriverCallCount() int {
	fake.driverMutex.RLock()
	defer fake.driverMutex.RUnlock()
	return len(fake.driverArgsForCall)
}

func (fake *FakeConfig) DriverCalls(stub func() string) {
	fake.driverMutex.Lock()
	defer fake.driverMutex.Unlock()
	fake.DriverStub = stub
}

func (fake *FakeConfig) DriverReturns(result1 string) {
	fake.driverMutex.Lock()
	defer fake.driverMutex.Unlock()
	fake.DriverStub = nil
	fake.driverReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) DriverReturnsOnCall(i int, result1 string) {
	fake.driverMutex.Lock()
	defer fake.driverMutex.Unlock()
	fake.DriverStub = nil
	if fake.driverReturnsOnCall == nil {
		fake.driverReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.driverReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConfig) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.connectionStringMutex.RLock()
	defer fake.connectionStringMutex.RUnlock()
	fake.driverMutex.RLock()
	defer fake.driverMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConfig) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ sql.Config = new(FakeConfig)
