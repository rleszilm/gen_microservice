package generator

import (
	"bytes"
	"fmt"
	"path"
	"strings"
	"text/template"

	"github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/generator"
	"github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms/annotations"
	"google.golang.org/protobuf/compiler/protogen"
)

// MicroService is a struct that generates a service file.
type MicroService struct {
	Outfile *protogen.GeneratedFile
	File    *protogen.File
	Service *protogen.Service
	Opts    *annotations.ServiceOptions
}

func (m *MicroService) render() error {
	steps := []func() error{
		m.definePackage,
		m.defineMicroService,
		m.defineService,
	}

	for _, s := range steps {
		if err := s(); err != nil {
			return err
		}
	}

	return nil
}

func (m *MicroService) definePackage() error {
	tmplSrc := `// Package {{ PackageName .File }} is generated by protoc-gen-go-genms. *DO NOT EDIT*
package {{ PackageName .File }}

`

	tmpl, err := template.New("definePackage").
		Funcs(template.FuncMap{
			"PackageName": generator.PackageName,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, m); err != nil {
		return err
	}

	if _, err := m.Outfile.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (m *MicroService) defineMicroService() error {
	tmplSrc := `// {{ ServiceName .M.Service }}ServerService implements {{ ServiceName .M.Service }}Service
type {{ ServiceName .M.Service }}ServerService struct {
	{{ .P.Service }}.Deps
	
	impl {{ ServiceName .M.Service }}Server
	grpcServer *{{ .P.GRPCService }}.Server
	{{ if .M.Opts.Rest -}} restServer *{{ .P.RESTService }}.Server {{- end }}
	{{ if .M.Opts.Graphql -}} graphqlServer *{{ .P.GraphQLService }}.Server {{- end }}
}

`

	tmpl, err := template.New("defineMicroService").
		Funcs(template.FuncMap{
			"ServiceName": generator.ServiceName,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Service":     generator.QualifiedPackageName(m.Outfile, "github.com/rleszilm/gen_microservice/service"),
		"GRPCService": generator.QualifiedPackageName(m.Outfile, "github.com/rleszilm/gen_microservice/service/grpc"),
	}
	if m.Opts.Graphql {
		p["GraphQLService"] = generator.QualifiedPackageName(m.Outfile, "github.com/rleszilm/gen_microservice/service/graphql")
	}
	if m.Opts.Rest {
		p["RESTService"] = generator.QualifiedPackageName(m.Outfile, "github.com/rleszilm/gen_microservice/service/rest")
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"M": m,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := m.Outfile.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (m *MicroService) defineService() error {
	tmplSrc := `{{- $M := .M -}}
// Initialize implements service.Service.Initialize
func (s *{{ ServiceName $M.Service }}ServerService) Initialize(ctx {{ .P.Context }}.Context) error {
	s.grpcServer.WithService(func(server *{{ .P.GRPC }}.Server) {
		Register{{ ServiceName $M.Service }}Server(server, s.impl)
	})
	{{ if $M.Opts.Rest }}
		if err := s.restServer.WithGrpcProxyHandler(ctx, "{{ ServiceName $M.Service }}", Register{{ ServiceName $M.Service }}HandlerFromEndpoint); err != nil {
			return err
		}
	{{- end }}
	{{ if $M.Opts.Graphql }}
		if err := s.graphqlServer.WithGrpcProxy(ctx, "{{ ServiceName $M.Service }}", Register{{ ServiceName $M.Service }}GraphqlWithOptions); err != nil {
			return err
		}
	{{- end }}
	return nil
}
// Shutdown implements service.Service.Shutdown
func (s *{{ ServiceName $M.Service }}ServerService) Shutdown(_ {{ .P.Context }}.Context) error {
	return nil
}

// NameOf returns the name of the service
func (s *{{ ServiceName $M.Service }}ServerService) NameOf() string {
	return "{{ ServiceName $M.Service | ToDashCase | ToLower }}"
}

// String returns the string name of the service
func (s *{{ ServiceName $M.Service }}ServerService) String() string {
	return s.NameOf()
}

// New{{ ServiceName $M.Service }}ServerService returns a new {{ ServiceName $M.Service }}ServerService
func New{{ ServiceName $M.Service }}ServerService(impl {{ ServiceName $M.Service }}Server, grpcServer *{{ .P.GRPCService }}.Server {{- if $M.Opts.Rest }}, restServer *{{ .P.RESTService }}.Server{{ end }} {{- if $M.Opts.Graphql }}, graphqlServer *{{ .P.GraphQLService }}.Server{{ end }}) *{{ ServiceName $M.Service }}ServerService {
	server := &{{ ServiceName $M.Service }}ServerService{
		impl: impl,
		grpcServer: grpcServer,
		{{ if $M.Opts.Rest -}} restServer: restServer,{{- end }}
		{{ if $M.Opts.Graphql -}} graphqlServer: graphqlServer,{{- end }}
	}

	if asService, ok := impl.({{ .P.Service }}.Service); ok {
		server.WithDependencies(asService)
	}

	grpcServer.WithDependencies(server)
	{{ if $M.Opts.Rest -}}
		restServer.WithDependencies(server)
	{{- end }}
	{{ if $M.Opts.Graphql -}}
		graphqlServer.WithDependencies(server)
	{{- end }}
	return server
}
`

	tmpl, err := template.New("defineService").
		Funcs(template.FuncMap{
			"ServiceName": generator.ServiceName,
			"ToLower":     strings.ToLower,
			"ToDashCase":  generator.ToDashCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Context":     generator.QualifiedPackageName(m.Outfile, "context"),
		"GRPC":        generator.QualifiedPackageName(m.Outfile, "google.golang.org/grpc"),
		"GRPCService": generator.QualifiedPackageName(m.Outfile, "github.com/rleszilm/gen_microservice/service/grpc"),
		"Service":     generator.QualifiedPackageName(m.Outfile, "github.com/rleszilm/gen_microservice/service"),
	}
	if m.Opts.Graphql {
		p["GraphQLService"] = generator.QualifiedPackageName(m.Outfile, "github.com/rleszilm/gen_microservice/service/graphql")
	}
	if m.Opts.Rest {
		p["RESTService"] = generator.QualifiedPackageName(m.Outfile, "github.com/rleszilm/gen_microservice/service/rest")
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"M": m,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := m.Outfile.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

// NewMicroService returns a new collection renderer.
func NewMicroService(plugin *protogen.Plugin, file *protogen.File, svc *protogen.Service, opts *annotations.ServiceOptions) *MicroService {
	base := path.Base(file.GeneratedFilenamePrefix)
	dir := path.Dir(file.GeneratedFilenamePrefix)
	filename := path.Join(dir, fmt.Sprintf("%s.genms.%s.go", base, strings.ToLower(svc.GoName)))
	outFile := plugin.NewGeneratedFile(filename, ".")

	return &MicroService{
		Outfile: outFile,
		File:    file,
		Service: svc,
		Opts:    opts,
	}
}

// GenerateMicroService generates the dal interface for the collection
func GenerateMicroService(plugin *protogen.Plugin, file *protogen.File, svc *protogen.Service, opts *annotations.ServiceOptions) error {
	c := NewMicroService(plugin, file, svc, opts)
	return c.render()
}
