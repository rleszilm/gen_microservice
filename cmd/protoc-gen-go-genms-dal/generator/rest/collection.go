package rest

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/annotations"
	"github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/generator"
	generator_sql "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/generator/sql"
	protocgenlib "github.com/rleszilm/gen_microservice/internal/protoc-gen-lib"
	"google.golang.org/protobuf/compiler/protogen"
)

// Collection is a struct that generates a collection file.
type Collection struct {
	File    *File
	Message *protocgenlib.Message
	Fields  *protocgenlib.Fields
	Queries []*Query
}

func (c *Collection) render() error {
	steps := []func() error{
		c.definePackage,
		c.defineCollection,
		c.defineService,
		c.defineDefaultQueries,
		c.defineQueries,
		c.defineNewCollection,
		c.defineScanner,
		c.defineConfig,
		c.defineQueryProvider,
		c.defineMetrics,
	}

	for _, s := range steps {
		if err := s(); err != nil {
			return err
		}
	}

	return nil
}

func (c *Collection) definePackage() error {
	tmplSrc := `// Package rest_{{ .File.DalPackageName }} is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package rest_{{ .File.DalPackageName }}
`

	tmpl, err := template.New("definePackage").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, c); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineCollection() error {
	tmplSrc := `{{ with $state := . }}
// {{ .C.Message.Name }}Collection is an autogenerated implementation of {{ .C.Message.QualifiedDalType }}Collection.
type {{ .C.Message.Name }}Collection struct {
	{{ .P.Collection }}.Unimplemented{{ .C.Message.Name }}Collection

	client *{{ .P.HTTP }}.Client
	config *{{ .C.Message.Name }}Config
	
	queries {{ .C.Message.Name }}QueryProvider
}
{{ end }}
`

	tmpl, err := template.New("defineCollection").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Collection": c.File.QualifiedPackageName(c.File.DalPackagePath()),
		"HTTP":       c.File.QualifiedPackageName("net/http"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineService() error {
	tmplSrc := `// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *{{ .C.Message.Name }}Collection) Initialize(_ {{ .P.Context }}.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *{{ .C.Message.Name }}Collection) Shutdown(_ {{ .P.Context }}.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *{{ .C.Message.Name }}Collection) NameOf() string {
	return "rest_{{ .C.File.DalPackageName }}_" + x.config.Name
}

// String returns a string identifier for the service.
func (x *{{ .C.Message.Name }}Collection) String() string {
	return x.NameOf()
}
`

	tmpl, err := template.New("defineService").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Context": c.File.QualifiedPackageName("context"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineDefaultQueries() error {
	tmplSrc := `// All implements {{ .C.Message.QualifiedDalType }}Collection.All
func (x *{{ .C.Message.Name }}Collection) All(ctx {{ .P.Context }}.Context) ([]*{{ .C.Message.QualifiedType }}, error) {
	scheme, method, host, path, headers, _, _ := x.queries.All()

	url := url.URL{
		Scheme: scheme,
		Host: host,
		Path: path,
	}

	req, err := http.NewRequest(method, url.String(), nil)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		req.Header.Add(k, v)
	}

	return x.find(ctx, "all", req)
}

func (x *{{ .C.Message.Name }}Collection) find(ctx {{ .P.Context }}.Context, label string, req *http.Request) ([]*{{ .C.Message.QualifiedType }}, error) {
	var err error
	start := {{ .P.Time }}.Now()
	{{ .P.Stats }}.Record(ctx, {{ ToCamelCase (.C.Message.Name) }}Inflight.M(1))
	defer func() {
		stop := {{ .P.Time }}.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64({{ .P.Time }}.Millisecond)

		if err != nil {
			ctx, err = {{ .P.Tag }}.New(ctx,
				{{ .P.Tag }}.Upsert({{ ToCamelCase (.C.Message.Name) }}QueryError, label),
			)
		}

		ctx, err = {{ .P.Tag }}.New(ctx,
			{{ .P.Tag }}.Upsert({{ ToCamelCase (.C.Message.Name) }}QueryName, label),
		)

		{{ .P.Stats }}.Record(ctx, {{ ToCamelCase (.C.Message.Name) }}Latency.M(dur), {{ ToCamelCase (.C.Message.Name) }}Inflight.M(-1))
	}()

	req.WithContext(ctx)
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}

	buff, err := {{ .P.IOUtil }}.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	{{ .C.Message.Name }}s := []*{{ .C.Message.QualifiedType }}{}
	if err := {{ .P.JSON }}.Unmarshal(buff, &{{ .C.Message.Name }}s); err != nil {
		return nil, err
	}
	return {{ .C.Message.Name }}s, nil
}
`

	tmpl, err := template.New("defineDefaultQueries").
		Funcs(template.FuncMap{
			"ToCamelCase": generator.ToCamelCase,
			"ToLower":     strings.ToLower,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Context": c.File.QualifiedPackageName("context"),
		"Time":    c.File.QualifiedPackageName("time"),
		"Tag":     c.File.QualifiedPackageName("go.opencensus.io/tag"),
		"Stats":   c.File.QualifiedPackageName("go.opencensus.io/stats"),
		"URL":     c.File.QualifiedPackageName("net/url"),
		"JSON":    c.File.QualifiedPackageName("encoding/json"),
		"IOUtil":  c.File.QualifiedPackageName("io/ioutil"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineQueries() error {
	tmplSrc := `{{ range .Queries }}
	{{ . }}
{{ end }}
`

	tmpl, err := template.New("defineQueries").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	queries := []string{}
	for _, q := range c.Opts.Queries {
		query, err := QueryMethod(c.Outfile, c.Message, c.Fields, q)
		if err != nil {
			return err
		}
		queries = append(queries, query)
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{"Queries": queries}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineNewCollection() error {
	tmplSrc := `// New{{ .C.Message.Name }}Collection returns a new {{ .C.Message.Name }}Collection.
func New{{ .C.Message.Name }}Collection(queries {{ .C.Message.Name }}QueryProvider, config *{{ .C.Message.Name }}Config) (*{{ .C.Message.Name }}Collection, error) {
	register{{ ToTitleCase (.C.Message.Name) }}MetricsOnce.Do(register{{ ToTitleCase (.C.Message.Name) }}Metrics)

	coll := &{{ .C.Message.Name }}Collection{
		Unimplemented{{ .C.Message.Name }}Collection: {{ .P.Collection }}.Unimplemented{{ .C.Message.Name }}Collection{},
		config: config,
		queries: queries,
		client: &{{ .P.HTTP }}.Client{
			Timeout: config.Timeout,
		},
	}
	
	return coll, nil
}
`

	tmpl, err := template.New("defineNewCollection").
		Funcs(template.FuncMap{
			"ToTitleCase": generator.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Collection": c.File.QualifiedPackageName(c.File.DalPackagePath()),
		"HTTP":       c.File.QualifiedPackageName("net/http"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineScanner() error {
	tmplSrc := `// {{ .C.Message.Name }}Scanner is an autogenerated struct that
// is used to parse query results.
type {{ .C.Message.Name }}Scanner struct {
	{{ range .ScanFields -}}
		{{ . }}
	{{ end }}
}
		
// {{ .C.Message.Name }} returns a new {{ .C.Message.QualifiedType }} populated with scanned values.
func (x *{{ .C.Message.Name }}Scanner) {{ .C.Message.Name }}() *{{ .C.Message.QualifiedType }} {
	return &{{ .C.Message.QualifiedType }}{
		{{ range .ScanValues -}}
			{{ . }},
		{{ end }}
	}
}
`

	tmpl, err := template.New("defineScanner").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	scannerFields := []string{}
	scannerValues := []string{}
	for _, q := range c.Fields.QueryNames() {
		field := c.Fields.ByQueryName(q)
		fname := generator.GoFieldName(field)

		pn, err := generator_sql.ProtoToNullType(c.Outfile, field)
		if err != nil {
			return err
		}
		scannerFields = append(scannerFields, fmt.Sprintf("%s %s `json:\"%s\"`", fname, pn, q))

		nt, err := generator_sql.NullTypeToGoType(c.Outfile, "x.", fname, field)
		if err != nil {
			return err
		}
		scannerValues = append(scannerValues, fmt.Sprintf("%s: %s", fname, nt))
	}

	p := map[string]string{}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C":          c,
		"P":          p,
		"ScanFields": scannerFields,
		"ScanValues": scannerValues,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineConfig() error {
	tmplSrc := `// {{ .C.Message.Name }}Config is a struct that can be used to configure a {{ .C.Message.Name }}Collection
	type {{ .C.Message.Name }}Config struct {
		Name string ` + "`" + `envconfig:"name"` + "`" + `
		Timeout {{ .P.Time }}.Duration ` + "`" + `envconfig:"timeout" default:"5s"` + "`" + `
		Headers map[string]string ` + "`" + `envconfig:"headers"` + "`" + `
	}
`

	tmpl, err := template.New("defineConfig").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Time": c.File.QualifiedPackageName("time"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineQueryProvider() error {
	tmplSrc := `// {{ .C.Message.Name }}QueryProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . {{ .C.Message.Name }}QueryProvider
type {{ .C.Message.Name }}QueryProvider interface {
	All() (scheme string, method string, host string, path string, headers map[string]string, query []string, body []string)
	{{ range .C.Opts.Queries -}}
		{{ QueryProviderMethod . }}
	{{ end -}}
}

// {{ .C.Message.Name }}QueryDetails is a function that provides the data needed to perform a query.
type {{ .C.Message.Name }}QueryDetails func() (scheme string, method string, host string, path string, headers map[string]string, query []string, body {{ .P.IO }}.Reader)
`

	tmpl, err := template.New("defineQueryProvider").
		Funcs(template.FuncMap{
			"QueryProviderMethod": QueryProviderMethod,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"IO": c.File.QualifiedPackageName("io"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (c *Collection) defineMetrics() error {
	tmplSrc := `// define metrics
	var (
		{{ ToCamelCase (.C.Message.Name) }}QueryName = {{ .P.Tag }}.MustNewKey("dal_rest_{{ ToSnakeCase (.C.Message.Name) }}")
		{{ ToCamelCase (.C.Message.Name) }}QueryCode = {{ .P.Tag }}.MustNewKey("dal_rest_{{ ToSnakeCase (.C.Message.Name) }}_code")
		{{ ToCamelCase (.C.Message.Name) }}QueryError = {{ .P.Tag }}.MustNewKey("dal_rest_{{ ToSnakeCase (.C.Message.Name) }}_error")
	
		{{ ToCamelCase (.C.Message.Name) }}Latency = stats.Float64("{{ ToSnakeCase (.C.Message.Name) }}_latency", "Latency of {{ .C.Message.Name }} queries", stats.UnitMilliseconds)
		{{ ToCamelCase (.C.Message.Name) }}Inflight = stats.Int64("{{ ToSnakeCase (.C.Message.Name) }}_inflight", "Count of {{ .C.Message.Name }} queries in flight", stats.UnitDimensionless)
	
		register{{ ToTitleCase (.C.Message.Name) }}MetricsOnce {{ .P.Sync }}.Once
	)
	
	func register{{ ToTitleCase (.C.Message.Name) }}Metrics() {
		views := []*{{ .P.View }}.View{
			{
				Name:        "dal_rest_{{ ToSnakeCase (.C.Message.Name) }}_latency",
				Measure:     {{ ToCamelCase (.C.Message.Name) }}Latency,
				Description: "The distribution of the query latencies",
				TagKeys:     []{{ .P.Tag }}.Key{ {{ ToCamelCase (.C.Message.Name) }}QueryName, {{ ToCamelCase (.C.Message.Name) }}QueryCode, {{ ToCamelCase (.C.Message.Name) }}QueryError},
				Aggregation: {{ .P.View }}.Distribution(0, 25, 100, 200, 400, 800, 10000),
			},
			{
				Name:        "dal_rest_{{ ToSnakeCase (.C.Message.Name) }}_inflight",
				Measure:     {{ ToCamelCase (.C.Message.Name) }}Inflight,
				Description: "The number of queries being processed",
				TagKeys:     []{{ .P.Tag }}.Key{ {{ ToCamelCase (.C.Message.Name) }}QueryName, {{ ToCamelCase (.C.Message.Name) }}QueryCode},
				Aggregation: {{ .P.View }}.Sum(),
			},
		}
	
		if err := {{ .P.View }}.Register(views...); err != nil {
			{{ .P.Log }}.Fatal("Cannot register metrics:", err)
		}
	}
`

	tmpl, err := template.New("defineMetrics").
		Funcs(template.FuncMap{
			"ToCamelCase": generator.ToCamelCase,
			"ToSnakeCase": generator.ToSnakeCase,
			"ToTitleCase": generator.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Log":  c.File.QualifiedPackageName("log"),
		"Sync": c.File.QualifiedPackageName("sync"),
		"Tag":  c.File.QualifiedPackageName("go.opencensus.io/tag"),
		"View": c.File.QualifiedPackageName("go.opencensus.io/stats/view"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"C": c,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := c.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

// NewCollection returns a new collection renderer.
func NewCollection(plugin *protogen.Plugin, pfile *protogen.File, pmsg *protogen.Message, popts *annotations.DalOptions) *Collection {
	file := NewFile(plugin, pfile, pmsg)
	msg := protocgenlib.NewMessage(file.Outfile(), pmsg)
	fields := protocgenlib.NewFields(msg)

	return &Collection{
		File:        file,
		Message:     msg,
		Queries:     queries,
		Fields:      fields,
		QueryFields: strings.Join(fields.QueryNames(), ", "),
	}
}

// GenerateCollection generates the dal interface for the collection
func GenerateCollection(plugin *protogen.Plugin, file *protogen.File, msg *protogen.Message, opts *annotations.DalOptions) error {
	c := NewCollection(plugin, file, msg, opts)
	return c.render()
}

// NullTypeToGoType returns a statement that gives the value of the sql nulltype as the
// required go type.
func NullTypeToGoType(outfile *protogen.GeneratedFile, obj string, name string, field *protogen.Field) (string, error) {
	return generator_sql.NullTypeToGoType(outfile, obj, name, field)
}

// ProtoToNullType returns the sql null type for the given proto type
func ProtoToNullType(outfile *protogen.GeneratedFile, field *protogen.Field) (string, error) {
	return generator_sql.ProtoToNullType(outfile, field)
}
