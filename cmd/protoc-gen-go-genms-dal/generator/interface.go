package generator

import (
	"bytes"
	"fmt"
	"path"
	"strings"
	"text/template"

	"github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/annotations"
	protocgenlib "github.com/rleszilm/genms/internal/protoc-gen-lib"
	"google.golang.org/protobuf/compiler/protogen"
)

// Interface generates the interface for the dal type.
type Interface struct {
	File    *File
	Message *Message
	Fields  *Fields
	Opts    *annotations.DalOptions
}

// NewInterface returns a new Interfaces
func NewInterface(plugin *protogen.Plugin, file *protogen.File, msg *protogen.Message, opts *annotations.DalOptions) *Interface {
	base := path.Base(file.GeneratedFilenamePrefix)
	dir := path.Dir(file.GeneratedFilenamePrefix)
	filename := path.Join(dir, fmt.Sprintf("dal/%s.genms.dal.%s.go", base, strings.ToLower(msg.GoIdent.GoName)))
	outfile := plugin.NewGeneratedFile(filename, ".")

	ifile := NewFile(outfile, file)
	imsg := NewMessage(ifile, msg)
	ifields := NewFields(imsg)

	return &Interface{
		File:    ifile,
		Message: imsg,
		Fields:  ifields,
		Opts:    opts,
	}
}

// GenerateInterface generates the dal interface for the collection
func GenerateInterface(plugin *protogen.Plugin, file *protogen.File, msg *protogen.Message, opts *annotations.DalOptions) error {
	i := NewInterface(plugin, file, msg, opts)
	return i.render()
}

func (i *Interface) render() error {
	steps := []func() error{
		i.definePackage,
		i.defineErrors,
		i.defineInterface,
		i.defineFilter,
	}

	for _, s := range steps {
		if err := s(); err != nil {
			return err
		}
	}

	return nil
}

func (i *Interface) definePackage() error {
	tmplSrc := `// Package {{ .File.PackageName }} is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package {{ .File.PackageName }}

`

	tmpl, err := template.New("defineInterfacePackage").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, i); err != nil {
		return err
	}

	if _, err := i.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (i *Interface) defineErrors() error {
	tmplSrc := `var (
	// Err{{ .I.Message.Name }}CollectionMethodImpl is returned when the called method is not implemented.
	Err{{ .I.Message.Name }}CollectionMethodImpl = {{ .P.Errors }}.New("{{ .I.Message.Name }}Collection method is not implemented")
)

`

	tmpl, err := template.New("defineInterfaceErrors").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Errors": i.File.QualifiedPackageName("errors"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"I": i,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := i.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (i *Interface) defineInterface() error {
	tmplSrc := `// {{ .I.Message.Name }}Collection is an autogenerated interface that can be used to interact with a collection of {{ .I.Message.Name }} objects.
//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . {{ .I.Message.Name }}Collection
type {{ .I.Message.Name }}Collection interface {
	{{ .P.Service }}.Service

	{{ .I.Message.Name }}CollectionReader
	{{ .I.Message.Name }}CollectionWriter
}

// {{ .I.Message.Name }}CollectionWriter is an autogenerated interface that can be used to write to a collection of {{ .I.Message.Name }} objects.
//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . {{ .I.Message.Name }}CollectionWriter
type {{ .I.Message.Name }}CollectionWriter interface {
	Insert({{ .P.Context }}.Context, *{{ .I.Message.QualifiedKind }}) (*{{ .I.Message.QualifiedKind }}, error)
	Upsert({{ .P.Context }}.Context, *{{ .I.Message.QualifiedKind }}) (*{{ .I.Message.QualifiedKind }}, error)
}

// {{ .I.Message.Name }}CollectionReader is an autogenerated interface that can be used to query a collection
// of {{ .I.Message.Name }} objects. The queries and their values are taken from the representative proto message.
//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . {{ .I.Message.Name }}CollectionReader
type {{ .I.Message.Name }}CollectionReader interface {
	All({{ .P.Context }}.Context) ([]*{{ .I.Message.QualifiedKind }}, error)
	Filter({{ .P.Context }}.Context, *{{ .I.Message.Name }}Filter) ([]*{{ .I.Message.QualifiedKind }}, error)
	
}

`

	//{{ range .opts.Queries -}}
	//{{ ToTitleCase .Name }}({{ $state.P.Context }}.Context{{ range .Args -}}, {{ GoFieldType $state.outfile ($state.fields.ByName .) }} {{- end }}) ([]*{{ QualifiedType $state.outfile $state.msg }}, error)
	//{{ end }}

	tmpl, err := template.New("defineInterfaceInterface").
		Funcs(template.FuncMap{}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Context": i.File.QualifiedPackageName("context"),
		"Errors":  i.File.QualifiedPackageName("errors"),
		"Service": i.File.QualifiedPackageName("github.com/rleszilm/genms/service"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"I": i,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := i.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (i *Interface) defineFilter() error {
	tmplSrc := `{{- $i := .I -}}
// {{ $i.Message.Name }}Filter is an autogenerated struct that can be used in the generic queries against {{ $i.Message.Name }}Collection.
type {{ $i.Message.Name }}Filter struct {
	{{ range $name := $i.Fields.Names -}}
		{{- $f := ($i.Fields.ByName $name) -}}
		{{- if not $f.Ignore }}
			{{ ToTitleCase $f.Name }} {{ AsPointer $f.QualifiedKind -}}
		{{ end -}}
	{{ end -}}
}

`

	tmpl, err := template.New("defineInterfaceFilter").
		Funcs(template.FuncMap{
			"AsPointer":   protocgenlib.AsPointer,
			"ToTitleCase": protocgenlib.ToTitleCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Errors": i.File.QualifiedPackageName("errors"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"I": i,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := i.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}

func (i *Interface) defineAll() error {
	tmplSrc := `

{{ with $state := . }}



// Unimplemented{{ .Message.Name }}Collection is an autogenerated implementation of {{ .Message.Name }}Collection that returns an error when any
// method is called.
type Unimplemented{{ .Message.Name }}Collection struct {
	{{ .P.Service }}.Deps
}

// Insert implements {{ .Message.Name }}Collection.Insert
func (x *Unimplemented{{ MessageName $state.msg }}Collection) Insert(_ {{ .P.Context }}.Context, _ *{{ QualifiedType .outfile .msg }}) (*{{ QualifiedType .outfile .msg }}, error) {
	return nil, Err{{ MessageName $state.msg }}CollectionMethodImpl
}

// Upsert implements {{ .Message.Name }}Collection.Upsert
func (x *Unimplemented{{ MessageName $state.msg }}Collection) Upsert(_ {{ .P.Context }}.Context, _ *{{ QualifiedType .outfile .msg }}) (*{{ QualifiedType .outfile .msg }}, error) {
	return nil, Err{{ MessageName $state.msg }}CollectionMethodImpl
}

// Filter implements {{ .Message.Name }}Collection.Filter
func (x *Unimplemented{{ MessageName $state.msg }}Collection) Filter(_ {{ .P.Context }}.Context, _ *{{ MessageName $state.msg }}Filter) ([]*{{ QualifiedType .outfile .msg }}, error) {
	return nil, Err{{ MessageName $state.msg }}CollectionMethodImpl
}

{{ range .opts.Queries -}}
	// {{ ToTitleCase .Name }} implements {{ MessageName $state.msg }}Collection.{{ ToTitleCase .Name }}
	func (x *Unimplemented{{ MessageName $state.msg }}Collection){{ ToTitleCase .Name }}(_ {{ $state.P.Context }}.Context{{ range .Args -}}, _ {{ GoFieldType $state.outfile ($state.fields.ByName .) }} {{- end }}) ([]*{{ QualifiedType $state.outfile $state.msg }}, error) {
		return nil, Err{{ MessageName $state.msg }}CollectionMethodImpl
	}
{{ end }}
{{ end }}

`

	tmpl, err := template.New("defineInterfaceBaseInterface").
		Funcs(template.FuncMap{
			"AsPointer":   protocgenlib.AsPointer,
			"ToTitleCase": protocgenlib.ToTitleCase,
			"ToSnakeCase": protocgenlib.ToSnakeCase,
		}).
		Parse(tmplSrc)

	if err != nil {
		return err
	}

	p := map[string]string{
		"Errors":  i.File.QualifiedPackageName("errors"),
		"Service": i.File.QualifiedPackageName("github.com/rleszilm/genms/service"),
		"Context": i.File.QualifiedPackageName("context"),
	}

	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, map[string]interface{}{
		"I": i,
		"P": p,
	}); err != nil {
		return err
	}

	if _, err := i.File.Write(buf.Bytes()); err != nil {
		return err
	}
	return nil
}
