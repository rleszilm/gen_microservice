package postgres

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/annotations"
	"github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/generator"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	interfaceTemplateSource = `// Package postgres_dal_{{ .file.GoPackageName }} is generated by protoc-gen-go-gsnms-dal. *DO NOT EDIT*
package postgres_dal_{{ .file.GoPackageName }}

{{ define "fields" }}{{ join .fieldNames ", " }}{{ end -}}

import (
	"bytes"
	"context"
	sqllib "database/sql"
	"fmt"
	"log"
	"sync"
	"time"
	"text/template"
	
	dal_{{ .file.GoPackageName }} {{ packageName .msg.GoIdent.GoImportPath.String "dal" }}
	"github.com/rleszilm/gen_microservice/sql"
	"go.opencensus.io/stats"
	"go.opencensus.io/stats/view"
	"go.opencensus.io/tag"
)

{{ with $state := . }}

// {{ .msg.GoIdent.GoName }}Collection is an autogenerated implementation of
// dal_{{ .file.GoPackageName }}.{{ .msg.GoIdent.GoName }}Collection.
type {{ .msg.GoIdent.GoName }}Collection struct {
	dal_{{ .file.GoPackageName }}.Unimplemented{{ .msg.GoIdent.GoName }}Collection

	db sql.DB
	config *{{ .msg.GoIdent.GoName }}Config

	{{ range .fields }}
		{{ .GoName }} {{ toGoType .Desc.Kind -}} 
	{{ end }}

	execUpsert string
	queryAll string
	{{ range .opts.Queries -}}
		{{ if not .StubOnly -}}
			query{{ toTitleCase .Name }} string
		{{- end }}
	{{ end -}}
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *{{ $state.msg.GoIdent.GoName }}Collection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *{{ $state.msg.GoIdent.GoName }}Collection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *{{ $state.msg.GoIdent.GoName }}Collection) NameOf() string {
	return "postgres_dal_{{ .file.GoPackageName }}_" + x.config.TableName
}

// String returns a string identifier for the service.
func (x *{{ $state.msg.GoIdent.GoName }}Collection) String() string {
	return x.NameOf()
}

// Upsert implements dal_{{ $state.file.GoPackageName }}.{{ $state.msg.GoIdent.GoName }}Collection.Upsert
func (x *{{ $state.msg.GoIdent.GoName }}Collection) Upsert(ctx context.Context, arg *{{ .qualifiedType }}) (*{{ .qualifiedType }}, error) {
	var err error
	start := time.Now()
	stats.Record(ctx, {{ toCamelCase .msg.GoIdent.GoName }}Inflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		
		if err != nil {
			ctx, err = tag.New(ctx,
				tag.Upsert({{ toCamelCase .msg.GoIdent.GoName }}QueryError, "{{ toLower $state.msg.GoIdent.GoName }}_upsert"),
			)
		}

		ctx, err = tag.New(ctx,
			tag.Upsert({{ toCamelCase .msg.GoIdent.GoName }}QueryName, "{{ toLower $state.msg.GoIdent.GoName }}_upsert"),
		)

		stats.Record(ctx, {{ toCamelCase .msg.GoIdent.GoName }}Latency.M(dur), {{ toCamelCase .msg.GoIdent.GoName }}Inflight.M(-1))
	}()	

	if _, err = x.db.Exec(ctx, x.config.ExecUpsert, arg); err != nil {
		return nil, err
	}

	return arg, nil
}

// All implements dal_{{ $state.file.GoPackageName }}.{{ $state.msg.GoIdent.GoName }}Collection.All
func (x *{{ $state.msg.GoIdent.GoName }}Collection) All(ctx context.Context) ([]*{{ .qualifiedType }}, error) {
	filter := &dal_{{ $state.file.GoPackageName }}.{{ $state.msg.GoIdent.GoName }}Fields{}
	return x.find(ctx, "all", x.queryAll, filter)
}

// Filter implements dal_{{ $state.file.GoPackageName }}.{{ $state.msg.GoIdent.GoName }}Collection.Filter
func (x *{{ $state.msg.GoIdent.GoName }}Collection) Filter(ctx context.Context, arg *dal_{{ $state.file.GoPackageName }}.{{ $state.msg.GoIdent.GoName }}Fields) ([]*{{ .qualifiedType }}, error) {
	query := "SELECT {{ template "fields" $state }} FROM " + x.config.TableName
	fields := ""

	{{ range .fields -}}
		if arg.{{ .GoName }} != nil {
			fields += "{{ toSnakeCase .GoName }} = :{{ toSnakeCase .GoName }} AND "
		}
	{{ end }}

	if fields != "" {
		query = fmt.Sprintf("%s WHERE %s 1=1", query, fields)
	}

	return x.find(ctx, "filter", query, arg)
}

{{ range .opts.Queries -}}
	{{- if not .StubOnly }}
		// {{ toTitleCase .Name }} implements dal_{{ $state.file.GoPackageName }}.{{ $state.msg.GoIdent.GoName }}Collection.{{ toTitleCase .Name }}
		func (x *{{ $state.msg.GoIdent.GoName }}Collection){{ toTitleCase .Name }}(ctx context.Context{{ range .Fields -}}, {{ toLower . }} {{ toFieldType . $state.msg }} {{- end }}) ([]*{{ $state.qualifiedType }}, error) {
			filter := &dal_{{ $state.file.GoPackageName }}.{{ $state.msg.GoIdent.GoName }}Fields{
				{{ range .Fields -}}
					{{ toTitleCase . }}: &{{ toLower . }},
				{{ end -}}
			}
			return x.find(ctx, "{{ toSnakeCase .Name }}", x.query{{ toTitleCase .Name }}, filter)
		}
	{{ end }}
{{ end }}

func (x *{{ $state.msg.GoIdent.GoName }}Collection) find(ctx context.Context, label string, query string, arg *dal_{{ $state.file.GoPackageName }}.{{ $state.msg.GoIdent.GoName }}Fields) ([]*{{ .qualifiedType }}, error) {
	var err error
	start := time.Now()
	stats.Record(ctx, {{ toCamelCase .msg.GoIdent.GoName }}Inflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		
		if err != nil {
			ctx, err = tag.New(ctx,
				tag.Upsert({{ toCamelCase .msg.GoIdent.GoName }}QueryError, label),
			)
		}

		ctx, err = tag.New(ctx,
			tag.Upsert({{ toCamelCase .msg.GoIdent.GoName }}QueryName, label),
		)

		stats.Record(ctx, {{ toCamelCase .msg.GoIdent.GoName }}Latency.M(dur), {{ toCamelCase .msg.GoIdent.GoName }}Inflight.M(-1))
	}()	
	
	rows, err := x.db.Query(ctx, query, arg)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	{{ $state.msg.GoIdent.GoName }}s := []*{{ .qualifiedType }}{}
	for rows.Next() {
		obj := &{{ .msg.GoIdent.GoName }}Scanner{}
		if err = rows.StructScan(obj); err != nil {
			return nil, err
		}
		{{ $state.msg.GoIdent.GoName }}s = append({{ $state.msg.GoIdent.GoName }}s, obj.{{ .msg.GoIdent.GoName }}())
	}
	return {{ $state.msg.GoIdent.GoName }}s, nil
}

// New{{ .msg.GoIdent.GoName }}Collection returns a new {{ .msg.GoIdent.GoName }}Collection.
func New{{ .msg.GoIdent.GoName }}Collection(db sql.DB, queries {{ .msg.GoIdent.GoName }}QueryTemplateProvider, config *{{ .msg.GoIdent.GoName }}Config) (*{{ .msg.GoIdent.GoName }}Collection, error) {
	register{{ toTitleCase .msg.GoIdent.GoName }}MetricsOnce.Do(register{{ toTitleCase .msg.GoIdent.GoName }}Metrics)
	
	coll := &{{ .msg.GoIdent.GoName }}Collection{
		Unimplemented{{ .msg.GoIdent.GoName }}Collection: dal_{{ .file.GoPackageName }}.Unimplemented{{ .msg.GoIdent.GoName }}Collection{},
		db: db,
		config: config,
	}

	queryReplacements := map[string]string{
		"table": config.TableName,
		"fields": "{{ template "fields" $state }}",
	}

	// generate Upsert exec
	if queries.Upsert() != "" {
		tmpl, err := template.New("execUpsert").Parse(queries.All())
		if err != nil {
			return nil, err
		}

		buf := &bytes.Buffer{}
		if err := tmpl.Execute(buf, queryReplacements); err != nil {
			return nil, err
		}
		coll.execUpsert = string(buf.Bytes())
	}

	// generate All query
	if queries.All() != "" {
		tmpl, err := template.New("queryAll").Parse(queries.All())
		if err != nil {
			return nil, err
		}

		buf := &bytes.Buffer{}
		if err := tmpl.Execute(buf, queryReplacements); err != nil {
			return nil, err
		}
		coll.queryAll = string(buf.Bytes())
	}

	{{ range .opts.Queries -}}
		{{- if not .StubOnly -}}
			// generate {{ toTitleCase .Name }} query
			if queries.{{ toTitleCase .Name }}() != "" {
				tmpl, err := template.New("query{{ toTitleCase .Name }}").Parse(queries.{{ toTitleCase .Name }}())
				if err != nil {
					return nil, err
				}

				buf := &bytes.Buffer{}
				if err := tmpl.Execute(buf, queryReplacements); err != nil {
					return nil, err
				}
				coll.query{{ toTitleCase .Name }} = string(buf.Bytes())
			}
		{{ end }}
	{{ end -}}

	return coll, nil
}

// {{ .msg.GoIdent.GoName }}Scanner is an autogenerated struct that
// is used to parse query results.
type {{ .msg.GoIdent.GoName }}Scanner struct {
	{{ range $i, $f := .fields }}
		{{ .GoName }} {{ sqlNullType $f.Desc.Kind -}} ` + "`" + `db:"{{ index $state.fieldNames $i }}"` + "`" + `
	{{- end }}
}

// {{ .msg.GoIdent.GoName }} returns a new {{ .qualifiedType }} populated with scanned values.
func (x *{{ .msg.GoIdent.GoName }}Scanner) {{ .msg.GoIdent.GoName }}() *{{ .qualifiedType }} {
	return &{{ .qualifiedType }}{
		{{ range .fields }}
			{{- .GoName }}: {{ fromSQLNullValue .GoName .Desc.Kind }},
		{{ end -}}
	}
}

// {{ .msg.GoIdent.GoName }}Config is a struct that can be used to configure a {{ .msg.GoIdent.GoName }}Collection
type {{ .msg.GoIdent.GoName }}Config struct {
	TableName string ` + "`" + `envconfig:"table"` + "`" + `
	ExecUpsert string
}

// {{ .msg.GoIdent.GoName }}QueryTemplateProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
type {{ .msg.GoIdent.GoName }}QueryTemplateProvider interface {
	Upsert() string
	All() string
	{{ range .opts.Queries -}}
		{{ if not .StubOnly -}}
			{{ toTitleCase .Name }}() string
		{{ end -}}
	{{ end -}}
}

// {{ .msg.GoIdent.GoName }}Queries provides auto-generated queries when possible. This is not gauranteed to be a complete
// implementation of the interface. This should be used as a base for the actual query provider used.
type {{ .msg.GoIdent.GoName }}Queries struct {
}

// All implements {{ $state.msg.GoIdent.GoName }}QueryTemplateProvider.All.
func (x *{{ $state.msg.GoIdent.GoName }}Queries) All() string {
	return ` + "`" + `SELECT {{ template "fields" $state }} FROM {{ "{{ table }}" }};` + "`" + `
}

{{ range .opts.Queries -}}
	{{ if not .StubOnly -}}
		// {{ toTitleCase .Name }} implements {{ $state.msg.GoIdent.GoName }}QueryTemplateProvider.{{ toTitleCase .Name }}.
		func (x *{{ $state.msg.GoIdent.GoName }}Queries) {{ toTitleCase .Name }}() string {
			return ` + "`" + `SELECT {{ "{{ fields }}" }} FROM {{ "{{ table }}" }}
			{{- if .Fields }}
				WHERE 
					{{ range .Fields }}
							{{- . }} = :{{ . }} AND
					{{ end }}1 = 1;` + "`" + `
				{{ end -}}
		}
	{{ end }}
{{ end }}

// define metrics
var (
	{{ toCamelCase .msg.GoIdent.GoName }}QueryName = tag.MustNewKey("postgres_dal_{{ toSnakeCase .msg.GoIdent.GoName }}")
	{{ toCamelCase .msg.GoIdent.GoName }}QueryError = tag.MustNewKey("postgres_dal_{{ toSnakeCase .msg.GoIdent.GoName }}_error")

	{{ toCamelCase .msg.GoIdent.GoName }}Latency = stats.Float64("{{ toSnakeCase .msg.GoIdent.GoName }}_latency", "Latency of {{ .msg.GoIdent.GoName }} queries", stats.UnitMilliseconds)
	{{ toCamelCase .msg.GoIdent.GoName }}Inflight = stats.Int64("{{ toSnakeCase .msg.GoIdent.GoName }}_inflight", "Count of {{ .msg.GoIdent.GoName }} queries in flight", stats.UnitDimensionless)

	register{{ toTitleCase .msg.GoIdent.GoName }}MetricsOnce sync.Once
)

func register{{ toTitleCase .msg.GoIdent.GoName }}Metrics() {
	views := []*view.View{
		{
			Name:        "{{ toSnakeCase .msg.GoIdent.GoName }}_latency",
			Measure:     {{ toCamelCase .msg.GoIdent.GoName }}Latency,
			Description: "The distribution of the query latencies",
			TagKeys:     []tag.Key{ {{ toCamelCase .msg.GoIdent.GoName }}QueryName, {{ toCamelCase .msg.GoIdent.GoName }}QueryError},
			Aggregation: view.Distribution(0, 25, 100, 200, 400, 800, 10000),
		},
		{
			Name:        "{{ toSnakeCase .msg.GoIdent.GoName }}_inflight",
			Measure:     {{ toCamelCase .msg.GoIdent.GoName }}Inflight,
			Description: "The number of queries being processed",
			TagKeys:     []tag.Key{ {{ toCamelCase .msg.GoIdent.GoName }}QueryName},
			Aggregation: view.Sum(),
		},
	}

	if err := view. Register(views...); err != nil {
		log.Fatal("Cannot register metrics:", err)
	}
}
{{ end }}
`
)

var (
	interfaceTemplate = template.Must(
		template.New("interface").
			Funcs(template.FuncMap{
				"toCamelCase":      generator.ToCamelCase,
				"toSnakeCase":      generator.ToSnakeCase,
				"toTitleCase":      generator.ToTitleCase,
				"toFieldType":      generator.ToFieldType,
				"toGoType":         generator.ToGoType,
				"packageName":      generator.PackageName,
				"join":             strings.Join,
				"toLower":          strings.ToLower,
				"sqlNullType":      sqlNullType,
				"sqlNullValue":     sqlNullValue,
				"fromSQLNullValue": fromSQLNullValue,
			}).
			Parse(interfaceTemplateSource))
)

// GenerateCollection generates the dal interface for the collection
func GenerateCollection(plugin *protogen.Plugin, file *protogen.File, msg *protogen.Message, opts *annotations.DalOptions) error {
	filename := fmt.Sprintf("dal/postgres/%s.genms.dal.%s.go", file.GeneratedFilenamePrefix, strings.ToLower(msg.GoIdent.GoName))
	outFile := plugin.NewGeneratedFile(filename, ".")
	qualifiedType := outFile.QualifiedGoIdent(msg.GoIdent)

	fields := []*protogen.Field{}
	fieldNames := []string{}
	for _, f := range msg.Fields {
		fOpts := f.Desc.Options()

		var fExt *annotations.DalFieldOptions
		if proto.HasExtension(fOpts, annotations.E_GenmsDalField) {
			ext := proto.GetExtension(fOpts, annotations.E_GenmsDalField)
			fExt = ext.(*annotations.DalFieldOptions)
		}

		if fExt != nil {
			if fExt.Ignore || (fExt.Sql != nil && fExt.Sql.Ignore) {
				continue
			}
			fields = append(fields, f)

			if fExt.Sql != nil && fExt.Sql.Column != "" {
				fieldNames = append(fieldNames, fExt.Sql.Column)
				continue
			}

			if fExt.FieldName != "" {
				fieldNames = append(fieldNames, fExt.FieldName)
				continue
			}

			fieldNames = append(fieldNames, string(f.Desc.Name()))
		} else {
			fields = append(fields, f)
			fieldNames = append(fieldNames, string(f.Desc.Name()))
		}
	}

	model := map[string]interface{}{
		"file":          file,
		"msg":           msg,
		"type":          msg.GoIdent.GoName,
		"qualifiedType": qualifiedType,
		"fields":        fields,
		"fieldNames":    fieldNames,
		"opts":          opts,
	}

	buf := &bytes.Buffer{}
	if err := interfaceTemplate.Execute(buf, model); err != nil {
		return err
	}

	if c, err := outFile.Write(buf.Bytes()); err != nil {
		fmt.Println("count not write", c, err)
		return err
	}

	return nil
}

func sqlNullType(t protoreflect.Kind) string {
	switch t.String() {
	case "bool":
		return "sqllib.NullBool"
	case "double":
		return "sqllib.NullFloat64"
	case "float":
		return "sqllib.NullFloat64"
	case "int32":
		return "sqllib.NullInt32"
	case "int64":
		return "sqllib.NullInt64"
	case "string":
		return "sqllib.NullString"
	default:
		return t.GoString()
	}
}

func sqlNullValue(t protoreflect.Kind) string {
	switch t.String() {
	case "bool":
		return "Bool"
	case "double":
		return "Float64"
	case "float":
		return "Float32"
	case "int32":
		return "Int32"
	case "int64":
		return "Int64"
	case "string":
		return "String"
	default:
		return "Value()"
	}
}

func fromSQLNullValue(field string, kind protoreflect.Kind) string {
	switch kind.String() {
	case "bool":
		return fmt.Sprintf("x.%s.Bool", field)
	case "double":
		return fmt.Sprintf("x.%s.Float64", field)
	case "float":
		return fmt.Sprintf("float32(x.%s.Float64)", field)
	case "int32":
		return fmt.Sprintf("x.%s.Int32", field)
	case "int64":
		return fmt.Sprintf("x.%s.Int64", field)
	case "string":
		return fmt.Sprintf("x.%s.String", field)
	default:
		return fmt.Sprintf("x.%s.Value()", field)
	}
}
