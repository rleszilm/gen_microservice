// Package cache_dal_users is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package cache_dal_users

import (
	context "context"
	sync "sync"
	time "time"

	keyvalue "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users/dal/keyvalue"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// UserUpdater is an autogenerated implementation of dal.UserUpdater.
type UserUpdater struct {
	name     string
	reader   keyvalue.UserReadAller
	writer   keyvalue.UserWriter
	key      keyvalue.UserKeyFunc
	interval time.Duration
	init     sync.Once
	done     chan struct{}
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *UserUpdater) Initialize(ctx context.Context) error {
	go x.init.Do(func() { x.update(ctx) })
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *UserUpdater) Shutdown(_ context.Context) error {
	return nil
}

func (x *UserUpdater) update(ctx context.Context) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(tagCacheCollection, "user"),
		tag.Upsert(tagCacheInstance, x.name),
		tag.Upsert(tagCacheMethod, "update"),
		tag.Upsert(tagCacheType, "updater"),
	)

	ticker := time.NewTicker(0)
	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			start := time.Now()
			stats.Record(ctx, measureInflight.M(1))

			vals, err := x.reader.All(ctx)
			if err == nil {
				for _, val := range vals {
					if err = x.writer.SetByKey(ctx, x.key(val), val); err != nil {
						break
					}
				}
			}
			stats.Record(ctx, measureInflight.M(-1))

			if err != nil {
				logs.Error("could not update User's:", err)
				stats.Record(ctx, measureError.M(1))
			}

			stop := time.Now()
			dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
			stats.Record(ctx, measureLatency.M(dur))

			if x.interval == 0 {
				logs.Info("User updater has no interval. Ceasing updates.")
				return
			}
			ticker.Reset(x.interval)
		}
	}
}

// NewUserUpdater returns a new UserUpdater.
func NewUserUpdater(n string, r keyvalue.UserReadAller, w keyvalue.UserWriter, k keyvalue.UserKeyFunc, i time.Duration) *UserUpdater {
	return &UserUpdater{
		name:     n,
		reader:   r,
		writer:   w,
		key:      k,
		interval: i,
		done:     make(chan struct{}),
	}
}
