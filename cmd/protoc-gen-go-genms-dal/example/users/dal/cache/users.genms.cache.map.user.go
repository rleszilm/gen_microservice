// Package cache_dal_users is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package cache_dal_users

import (
	context "context"
	time "time"

	users "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users"
	keyvalue "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users/dal/keyvalue"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// UserMap defines a Map base cache implementing keyvalue.UserReadWriter.
// If a key is queries that does not exist an attempt to read and store it is made.
type UserMap struct {
	name   string
	reader keyvalue.UserReader
	writer keyvalue.UserWriter
	cache  map[keyvalue.UserKey]*users.User
}

// GetByKey implements keyvalue.UserReadWriter.
func (x *UserMap) GetByKey(ctx context.Context, key keyvalue.UserKey) (*users.User, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(tagCacheCollection, "user"),
		tag.Upsert(tagCacheInstance, x.name),
		tag.Upsert(tagCacheMethod, "get"),
		tag.Upsert(tagCacheType, "map"),
	)
	stats.Record(ctx, measureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, measureLatency.M(dur), measureInflight.M(-1))
	}()

	if val, ok := x.cache[key]; ok {
		return val, nil
	}

	val, err := x.reader.GetByKey(ctx, key)
	if err != nil {
		x.cache[key] = val
		return val, nil
	}

	stats.Record(ctx, measureError.M(1))
	return nil, err
}

// SetByKey implements keyvalue.UserReadWriter.
func (x *UserMap) SetByKey(ctx context.Context, key keyvalue.UserKey, val *users.User) error {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(tagCacheCollection, "user"),
		tag.Upsert(tagCacheInstance, x.name),
		tag.Upsert(tagCacheMethod, "get"),
		tag.Upsert(tagCacheType, "map"),
	)
	stats.Record(ctx, measureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, measureLatency.M(dur), measureInflight.M(-1))
	}()

	if err := x.writer.SetByKey(ctx, key, val); err != nil {
		stats.Record(ctx, measureError.M(1))
		return err
	}

	x.cache[key] = val
	return nil
}

// NewUserMap returns a new UserMap cache.
func NewUserMap(name string, r keyvalue.UserReadAller, w keyvalue.UserWriter, i int) (*UserMap, error) {
	return &UserMap{
		name:   name,
		reader: r,
		writer: w,
		cache:  map[keyvalue.UserKey]*users.User{},
	}, nil
}
