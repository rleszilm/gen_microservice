// Package cache_dal_users is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package cache_dal_users

import (
	context "context"
	time "time"

	golang_lru "github.com/hashicorp/golang-lru"
	users "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users"
	keyvalue "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users/dal/keyvalue"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// UserLRU defines a LRU cache implementing keyvalue.UserReadWriter.
// If a key is queries that does not exist an attempt to read and store it is made.
type UserLRU struct {
	name   string
	reader keyvalue.UserReader
	writer keyvalue.UserWriter
	lru    *golang_lru.ARCCache
}

// GetByKey implements keyvalue.UserReadWriter.
func (x *UserLRU) GetByKey(ctx context.Context, key keyvalue.UserKey) (*users.User, error) {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(tagCacheCollection, "user"),
		tag.Upsert(tagCacheInstance, x.name),
		tag.Upsert(tagCacheMethod, "get"),
		tag.Upsert(tagCacheType, "lru"),
	)
	stats.Record(ctx, measureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, measureLatency.M(dur), measureInflight.M(-1))
	}()

	if val, ok := x.lru.Get(key); ok {
		stats.Record(ctx, measureHit.M(1))
		return val.(*users.User), nil
	}
	stats.Record(ctx, measureMiss.M(1))

	val, err := x.reader.GetByKey(ctx, key)
	if err != nil {
		x.lru.Add(key, val)
		return val, nil
	}

	stats.Record(ctx, measureError.M(1))
	return nil, err
}

// SetByKey implements keyvalue.UserReadWriter.
func (x *UserLRU) SetByKey(ctx context.Context, key keyvalue.UserKey, val *users.User) error {
	start := time.Now()
	ctx, _ = tag.New(ctx,
		tag.Upsert(tagCacheCollection, "user"),
		tag.Upsert(tagCacheInstance, x.name),
		tag.Upsert(tagCacheMethod, "set"),
		tag.Upsert(tagCacheType, "lru"),
	)
	stats.Record(ctx, measureInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, measureLatency.M(dur), measureInflight.M(-1))
	}()

	if err := x.writer.SetByKey(ctx, key, val); err != nil {
		stats.Record(ctx, measureError.M(1))
		return err
	}

	x.lru.Add(key, val)
	return nil
}

// NewUserLRU returns a new UserLRU cache.
func NewUserLRU(name string, r keyvalue.UserReadAller, w keyvalue.UserWriter, i int) (*UserLRU, error) {
	arc, err := golang_lru.NewARC(i)
	if err != nil {
		return nil, err
	}

	return &UserLRU{
		name:   name,
		reader: r,
		writer: w,
		lru:    arc,
	}, nil
}
