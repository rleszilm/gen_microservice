// Package rest_dal_users is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package rest_dal_users

import (
	bytes "bytes"
	context "context"
	json "encoding/json"
	fmt "fmt"
	ioutil "io/ioutil"
	log "log"
	http "net/http"
	url "net/url"
	strconv "strconv"
	sync "sync"
	template "text/template"
	time "time"

	copier "github.com/jinzhu/copier"
	users "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users"
	dal "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users/dal"
	stats "go.opencensus.io/stats"
	view "go.opencensus.io/stats/view"
	tag "go.opencensus.io/tag"
)

// UserCollection is an autogenerated implementation of dal.UserCollection.
type UserCollection struct {
	dal.UnimplementedUserCollection

	client *http.Client
	config *UserConfig

	url                     *url.URL
	urlAll                  string
	urlTmplOneParam         *template.Template
	urlTmplMultipleParam    *template.Template
	urlTmplMessageParam     *template.Template
	urlTmplWithComparator   *template.Template
	urlTmplWithRest         *template.Template
	urlTmplProviderStubOnly *template.Template
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *UserCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *UserCollection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *UserCollection) NameOf() string {
	return "rest_dal_users_" + x.config.Name
}

// String returns a string identifier for the service.
func (x *UserCollection) String() string {
	return x.NameOf()
}

// DoReq executes the given http request.
func (x *UserCollection) DoReq(ctx context.Context, label string, req *http.Request) ([]*users.User, error) {
	var err error
	var resp *http.Response
	start := time.Now()
	stats.Record(ctx, userInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if resp != nil {
			ctx, _ = tag.New(ctx,
				tag.Upsert(userQueryCode, strconv.Itoa(resp.StatusCode)),
			)
		}

		if err != nil {
			ctx, _ = tag.New(ctx,
				tag.Upsert(userQueryError, label),
			)
		}

		ctx, _ = tag.New(ctx,
			tag.Upsert(userQueryName, label),
		)

		stats.Record(ctx, userLatency.M(dur), userInflight.M(-1))
	}()

	ctx, cancel := context.WithTimeout(ctx, x.config.Timeout)
	defer cancel()

	resp, err = x.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, err
	}

	buff, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	UserScanners := []*UserScanner{}
	if err := json.Unmarshal(buff, &UserScanners); err != nil {
		return nil, err
	}

	Users := []*users.User{}
	for _, c := range UserScanners {
		Users = append(Users, c.User())
	}
	return Users, nil
}

// All implements dal.UserCollection.All
func (x *UserCollection) All(ctx context.Context) ([]*users.User, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)
	u.Path = x.urlAll

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "all", req)
}

// OneParam implements dal.UserCollection.OneParam
func (x *UserCollection) OneParam(ctx context.Context, scalar_int32 int32) ([]*users.User, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("scalar_int32", fmt.Sprintf("%v", scalar_int32))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplOneParam.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "one_param", req)
}

// MultipleParam implements dal.UserCollection.MultipleParam
func (x *UserCollection) MultipleParam(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32) ([]*users.User, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("scalar_int32", fmt.Sprintf("%v", scalar_int32))
	queryValues.Add("scalar_int64", fmt.Sprintf("%v", scalar_int64))
	queryValues.Add("scalar_float32", fmt.Sprintf("%v", scalar_float32))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplMultipleParam.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "multiple_param", req)
}

// MessageParam implements dal.UserCollection.MessageParam
func (x *UserCollection) MessageParam(ctx context.Context, obj_message *users.User_Message) ([]*users.User, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("obj_message", fmt.Sprintf("%v", obj_message))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplMessageParam.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "message_param", req)
}

// WithComparator implements dal.UserCollection.WithComparator
func (x *UserCollection) WithComparator(ctx context.Context, scalar_int32 int32) ([]*users.User, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("scalar_int32", fmt.Sprintf("%v", scalar_int32))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplWithComparator.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "with_comparator", req)
}

// WithRest implements dal.UserCollection.WithRest
func (x *UserCollection) WithRest(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32, scalar_float64 float64) ([]*users.User, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "POST",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}
	queryValues.Add("query_rest_scalar_int32", fmt.Sprintf("%v", scalar_int32))

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{"scalar_int64": &scalar_int64}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplWithRest.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	bodyValues := map[string]interface{}{"scalar_float32": &scalar_float32}
	bodyBytes, err := json.Marshal(bodyValues)
	if err != nil {
		return nil, err
	}
	bodyRC := ioutil.NopCloser(bytes.NewReader(bodyBytes))
	req.Body = bodyRC

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	req.Header.Add("scalar_float64", fmt.Sprintf("%v", scalar_float64))

	return x.DoReq(ctx, "with_rest", req)
}

// ProviderStubOnly implements dal.UserCollection.ProviderStubOnly
func (x *UserCollection) ProviderStubOnly(ctx context.Context) ([]*users.User, error) {
	u := &url.URL{}
	copier.Copy(u, x.url)

	req := &http.Request{
		Method: "GET",
		Header: http.Header{},
		URL:    u,
	}

	queryValues := url.Values{}

	req.URL.RawQuery = queryValues.Encode()

	pathValues := map[string]interface{}{}
	pathBuf := &bytes.Buffer{}
	if err := x.urlTmplProviderStubOnly.Execute(pathBuf, pathValues); err != nil {
		return nil, err
	}
	req.URL.Path = pathBuf.String()

	for k, v := range x.config.Headers {
		req.Header.Add(k, v)
	}

	return x.DoReq(ctx, "provider_stub_only", req)
}

// NewUserCollection returns a new UserCollection.
func NewUserCollection(client *http.Client, urls UserUrlTemplateProvider, config *UserConfig) (*UserCollection, error) {
	registerUserMetricsOnce.Do(registerUserMetrics)

	coll := &UserCollection{
		client: client,
		config: config,
	}

	u, err := url.Parse(config.URL)
	if err != nil {
		return nil, err
	}
	coll.url = u

	coll.urlAll = urls.All()
	if urls.OneParam() != "" {
		urlTmplOneParam, err := template.New("urlTmplOneParam").
			Funcs(template.FuncMap{}).
			Parse(urls.OneParam())
		if err != nil {
			return nil, err
		}
		coll.urlTmplOneParam = urlTmplOneParam
	}

	if urls.MultipleParam() != "" {
		urlTmplMultipleParam, err := template.New("urlTmplMultipleParam").
			Funcs(template.FuncMap{}).
			Parse(urls.MultipleParam())
		if err != nil {
			return nil, err
		}
		coll.urlTmplMultipleParam = urlTmplMultipleParam
	}

	if urls.MessageParam() != "" {
		urlTmplMessageParam, err := template.New("urlTmplMessageParam").
			Funcs(template.FuncMap{}).
			Parse(urls.MessageParam())
		if err != nil {
			return nil, err
		}
		coll.urlTmplMessageParam = urlTmplMessageParam
	}

	if urls.WithComparator() != "" {
		urlTmplWithComparator, err := template.New("urlTmplWithComparator").
			Funcs(template.FuncMap{}).
			Parse(urls.WithComparator())
		if err != nil {
			return nil, err
		}
		coll.urlTmplWithComparator = urlTmplWithComparator
	}

	if urls.WithRest() != "" {
		urlTmplWithRest, err := template.New("urlTmplWithRest").
			Funcs(template.FuncMap{}).
			Parse(urls.WithRest())
		if err != nil {
			return nil, err
		}
		coll.urlTmplWithRest = urlTmplWithRest
	}

	if urls.ProviderStubOnly() != "" {
		urlTmplProviderStubOnly, err := template.New("urlTmplProviderStubOnly").
			Funcs(template.FuncMap{}).
			Parse(urls.ProviderStubOnly())
		if err != nil {
			return nil, err
		}
		coll.urlTmplProviderStubOnly = urlTmplProviderStubOnly
	}

	return coll, nil
}

// UserScanner is an autogenerated struct that
// is used to parse query results.
type UserScanner struct {
	ScalarInt32   int32               `json:"scalar_int32"`
	ScalarInt64   int64               `json:"scalar_int64"`
	ScalarFloat32 float32             `json:"scalar_float32"`
	ScalarFloat64 float64             `json:"scalar_float64"`
	ScalarString  string              `json:"scalar_string"`
	ScalarBool    bool                `json:"scalar_bool"`
	ScalarEnum    users.User_Enum     `json:"scalar_enum"`
	ObjMessage    *users.User_Message `json:"obj_message"`

	Renamed         string `json:"aliased"`
	IgnoredPostgres string `json:"ignored_postgres"`
	RenamedPostgres string `json:"renamed_postgres"`

	RenamedRest string `json:"aliased_rest"`
}

// User returns a new users.User populated with scanned values.
func (x *UserScanner) User() *users.User {
	y := &users.User{}

	y.ScalarInt32 = x.ScalarInt32
	y.ScalarInt64 = x.ScalarInt64
	y.ScalarFloat32 = x.ScalarFloat32
	y.ScalarFloat64 = x.ScalarFloat64
	y.ScalarString = x.ScalarString
	y.ScalarBool = x.ScalarBool
	y.ScalarEnum = x.ScalarEnum
	y.ObjMessage = x.ObjMessage

	y.Renamed = x.Renamed
	y.IgnoredPostgres = x.IgnoredPostgres
	y.RenamedPostgres = x.RenamedPostgres

	y.RenamedRest = x.RenamedRest
	return y
}

// UserConfig is a struct that can be used to configure a UserCollection
type UserConfig struct {
	URL     string            `envconfig:"url"`
	Name    string            `envconfig:"name"`
	Timeout time.Duration     `envconfig:"timeout" default:"5s"`
	Headers map[string]string `envconfig:"headers"`
}

// UserUrlTemplateProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . UserUrlTemplateProvider
type UserUrlTemplateProvider interface {
	All() string
	OneParam() string
	MultipleParam() string
	MessageParam() string
	WithComparator() string
	WithRest() string
	ProviderStubOnly() string
}

// define metrics
var (
	userQueryName  = tag.MustNewKey("dal_rest_user")
	userQueryCode  = tag.MustNewKey("dal_rest_user_code")
	userQueryError = tag.MustNewKey("dal_rest_user_error")

	userLatency  = stats.Float64("user_latency", "Latency of User queries", stats.UnitMilliseconds)
	userInflight = stats.Int64("user_inflight", "Count of User queries in flight", stats.UnitDimensionless)

	registerUserMetricsOnce sync.Once
)

func registerUserMetrics() {
	views := []*view.View{
		{
			Name:        "dal_rest_user_latency",
			Measure:     userLatency,
			Description: "The distribution of the query latencies",
			TagKeys:     []tag.Key{userQueryName, userQueryCode, userQueryError},
			Aggregation: view.Distribution(0, 25, 100, 200, 400, 800, 10000),
		},
		{
			Name:        "dal_rest_user_inflight",
			Measure:     userInflight,
			Description: "The number of queries being processed",
			TagKeys:     []tag.Key{userQueryName, userQueryCode},
			Aggregation: view.Sum(),
		},
	}

	if err := view.Register(views...); err != nil {
		log.Fatal("Cannot register metrics:", err)
	}
}
