// Package rest_users is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package rest_users

import (
	bytes "bytes"
	context "context"
	sql "database/sql"
	json "encoding/json"
	fmt "fmt"
	types "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/annotations/types"
	users "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/example/users"
	dal "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/example/users/dal"
	stats "go.opencensus.io/stats"
	view "go.opencensus.io/stats/view"
	tag "go.opencensus.io/tag"
	latlng "google.golang.org/genproto/googleapis/type/latlng"
	io "io"
	ioutil "io/ioutil"
	log "log"
	http "net/http"
	url "net/url"
	sync "sync"
	time "time"
)

// UserCollection is an autogenerated implementation of dal.UserCollection.
type UserCollection struct {
	dal.UnimplementedUserCollection

	client *http.Client
	config *UserConfig

	queries UserQueryProvider
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *UserCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *UserCollection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *UserCollection) NameOf() string {
	return "rest_users_" + x.config.Name
}

// String returns a string identifier for the service.
func (x *UserCollection) String() string {
	return x.NameOf()
}

// All implements dal.UserCollection.All
func (x *UserCollection) All(ctx context.Context) ([]*users.User, error) {
	scheme, method, host, path, headers, _, _ := x.queries.All()

	url := url.URL{
		Scheme: scheme,
		Host:   host,
		Path:   path,
	}

	req, err := http.NewRequest(method, url.String(), nil)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		req.Header.Add(k, v)
	}

	return x.find(ctx, "all", req)
}

func (x *UserCollection) find(ctx context.Context, label string, req *http.Request) ([]*users.User, error) {
	var err error
	start := time.Now()
	stats.Record(ctx, userInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, err = tag.New(ctx,
				tag.Upsert(userQueryError, label),
			)
		}

		ctx, err = tag.New(ctx,
			tag.Upsert(userQueryName, label),
		)

		stats.Record(ctx, userLatency.M(dur), userInflight.M(-1))
	}()

	req.WithContext(ctx)
	resp, err := x.client.Do(req)
	if err != nil {
		return nil, err
	}

	buff, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	Users := []*users.User{}
	if err := json.Unmarshal(buff, &Users); err != nil {
		return nil, err
	}
	return Users, nil
}

// ById implements dal.UserCollection.ById
func (x *UserCollection) ById(ctx context.Context, id int64) ([]*users.User, error) {
	scheme, method, host, path, headers, args, body := x.queries.ById()

	values := url.Values{}
	for _, arg := range args {
		switch arg {
		case "id":
			values.Add("id", fmt.Sprintf("%v", id))
		}
	}

	bodyArgs := map[string]interface{}{}
	for _, arg := range body {
		switch arg {
		case "id":
			bodyArgs["id"] = id
		}
	}

	bodyBuf, err := json.Marshal(bodyArgs)
	if err != nil {
		return nil, err
	}

	bodyBytes := bytes.NewBuffer(bodyBuf)

	url := url.URL{
		Scheme:   scheme,
		Host:     host,
		Path:     path,
		RawQuery: values.Encode(),
	}

	req, err := http.NewRequest(method, url.String(), bodyBytes)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		req.Header.Add(k, v)
	}

	return x.find(ctx, "by_id", req)
}

// ByNameAndDivision implements dal.UserCollection.ByNameAndDivision
func (x *UserCollection) ByNameAndDivision(ctx context.Context, name string, division string) ([]*users.User, error) {
	scheme, method, host, path, headers, args, body := x.queries.ByNameAndDivision()

	values := url.Values{}
	for _, arg := range args {
		switch arg {
		case "name":
			values.Add("name", fmt.Sprintf("%v", name))
		case "division":
			values.Add("division", fmt.Sprintf("%v", division))
		}
	}

	bodyArgs := map[string]interface{}{}
	for _, arg := range body {
		switch arg {
		case "name":
			bodyArgs["name"] = name
		case "division":
			bodyArgs["division"] = division
		}
	}

	bodyBuf, err := json.Marshal(bodyArgs)
	if err != nil {
		return nil, err
	}

	bodyBytes := bytes.NewBuffer(bodyBuf)

	url := url.URL{
		Scheme:   scheme,
		Host:     host,
		Path:     path,
		RawQuery: values.Encode(),
	}

	req, err := http.NewRequest(method, url.String(), bodyBytes)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		req.Header.Add(k, v)
	}

	return x.find(ctx, "by_name_and_division", req)
}

// ByKind implements dal.UserCollection.ByKind
func (x *UserCollection) ByKind(ctx context.Context, kind users.User_Kind) ([]*users.User, error) {
	scheme, method, host, path, headers, args, body := x.queries.ByKind()

	values := url.Values{}
	for _, arg := range args {
		switch arg {
		case "kind":
			values.Add("kind", fmt.Sprintf("%v", kind))
		}
	}

	bodyArgs := map[string]interface{}{}
	for _, arg := range body {
		switch arg {
		case "kind":
			bodyArgs["kind"] = kind
		}
	}

	bodyBuf, err := json.Marshal(bodyArgs)
	if err != nil {
		return nil, err
	}

	bodyBytes := bytes.NewBuffer(bodyBuf)

	url := url.URL{
		Scheme:   scheme,
		Host:     host,
		Path:     path,
		RawQuery: values.Encode(),
	}

	req, err := http.NewRequest(method, url.String(), bodyBytes)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		req.Header.Add(k, v)
	}

	return x.find(ctx, "by_kind", req)
}

// ByPhone implements dal.UserCollection.ByPhone
func (x *UserCollection) ByPhone(ctx context.Context, phone *types.Phone) ([]*users.User, error) {
	scheme, method, host, path, headers, args, body := x.queries.ByPhone()

	values := url.Values{}
	for _, arg := range args {
		switch arg {
		case "phone":
			values.Add("phone", fmt.Sprintf("%v", phone))
		}
	}

	bodyArgs := map[string]interface{}{}
	for _, arg := range body {
		switch arg {
		case "phone":
			bodyArgs["phone"] = phone
		}
	}

	bodyBuf, err := json.Marshal(bodyArgs)
	if err != nil {
		return nil, err
	}

	bodyBytes := bytes.NewBuffer(bodyBuf)

	url := url.URL{
		Scheme:   scheme,
		Host:     host,
		Path:     path,
		RawQuery: values.Encode(),
	}

	req, err := http.NewRequest(method, url.String(), bodyBytes)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		req.Header.Add(k, v)
	}

	return x.find(ctx, "by_phone", req)
}

// ProviderStubOnly implements dal.UserCollection.ProviderStubOnly
func (x *UserCollection) ProviderStubOnly(ctx context.Context) ([]*users.User, error) {
	scheme, method, host, path, headers, args, body := x.queries.ProviderStubOnly()

	values := url.Values{}
	for _, arg := range args {
		switch arg {
		}
	}

	bodyArgs := map[string]interface{}{}
	for _, arg := range body {
		switch arg {
		}
	}

	bodyBuf, err := json.Marshal(bodyArgs)
	if err != nil {
		return nil, err
	}

	bodyBytes := bytes.NewBuffer(bodyBuf)

	url := url.URL{
		Scheme:   scheme,
		Host:     host,
		Path:     path,
		RawQuery: values.Encode(),
	}

	req, err := http.NewRequest(method, url.String(), bodyBytes)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		req.Header.Add(k, v)
	}

	return x.find(ctx, "provider_stub_only", req)
}

// NewUserCollection returns a new UserCollection.
func NewUserCollection(queries UserQueryProvider, config *UserConfig) (*UserCollection, error) {
	registerUserMetricsOnce.Do(registerUserMetrics)

	coll := &UserCollection{
		UnimplementedUserCollection: dal.UnimplementedUserCollection{},
		config:                      config,
		queries:                     queries,
		client: &http.Client{
			Timeout: config.Timeout,
		},
	}

	return coll, nil
}

// UserScanner is an autogenerated struct that
// is used to parse query results.
type UserScanner struct {
	Id            sql.NullInt64   `json:"id"`
	Name          sql.NullString  `json:"name"`
	Division      sql.NullString  `json:"division"`
	LifetimeScore sql.NullFloat64 `json:"lifetime_score"`
	LastScore     sql.NullFloat64 `json:"last_score"`
	LastWinnings  sql.NullInt32   `json:"payout"`
	Point         *types.Point    `json:"point"`
	Phone         *types.Phone    `json:"phone"`
	Geo           *latlng.LatLng  `json:"geo"`
	Kind          sql.NullInt32   `json:"type"`
	ByBackend     sql.NullString  `json:"by_backend_rest"`
}

// User returns a new users.User populated with scanned values.
func (x *UserScanner) User() *users.User {
	return &users.User{
		Id:            x.Id.Int64,
		Name:          x.Name.String,
		Division:      x.Division.String,
		LifetimeScore: x.LifetimeScore.Float64,
		LastScore:     float32(x.LastScore.Float64),
		LastWinnings:  x.LastWinnings.Int32,
		Point:         x.Point,
		Phone:         x.Phone,
		Geo:           x.Geo,
		Kind:          users.User_Kind(x.Kind.Int32),
		ByBackend:     x.ByBackend.String,
	}
}

// UserConfig is a struct that can be used to configure a UserCollection
type UserConfig struct {
	Name    string            `envconfig:"name"`
	Timeout time.Duration     `envconfig:"timeout" default:"5s"`
	Headers map[string]string `envconfig:"headers"`
}

// UserQueryProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
//go:generate go run github.com/maxbrunsfeld/counterfeiter/v6 . UserQueryProvider
type UserQueryProvider interface {
	All() (scheme string, method string, host string, path string, headers map[string]string, query []string, body []string)
	ById() (scheme string, method string, host string, path string, headers map[string]string, query []string, body []string)
	ByNameAndDivision() (scheme string, method string, host string, path string, headers map[string]string, query []string, body []string)
	ByKind() (scheme string, method string, host string, path string, headers map[string]string, query []string, body []string)
	ByPhone() (scheme string, method string, host string, path string, headers map[string]string, query []string, body []string)
	ProviderStubOnly() (scheme string, method string, host string, path string, headers map[string]string, query []string, body []string)
}

// UserQueryDetails is a function that provides the data needed to perform a query.
type UserQueryDetails func() (scheme string, method string, host string, path string, headers map[string]string, query []string, body io.Reader)

// define metrics
var (
	userQueryName  = tag.MustNewKey("dal_rest_user")
	userQueryCode  = tag.MustNewKey("dal_rest_user_code")
	userQueryError = tag.MustNewKey("dal_rest_user_error")

	userLatency  = stats.Float64("user_latency", "Latency of User queries", stats.UnitMilliseconds)
	userInflight = stats.Int64("user_inflight", "Count of User queries in flight", stats.UnitDimensionless)

	registerUserMetricsOnce sync.Once
)

func registerUserMetrics() {
	views := []*view.View{
		{
			Name:        "dal_rest_user_latency",
			Measure:     userLatency,
			Description: "The distribution of the query latencies",
			TagKeys:     []tag.Key{userQueryName, userQueryCode, userQueryError},
			Aggregation: view.Distribution(0, 25, 100, 200, 400, 800, 10000),
		},
		{
			Name:        "dal_rest_user_inflight",
			Measure:     userInflight,
			Description: "The number of queries being processed",
			TagKeys:     []tag.Key{userQueryName, userQueryCode},
			Aggregation: view.Sum(),
		},
	}

	if err := view.Register(views...); err != nil {
		log.Fatal("Cannot register metrics:", err)
	}
}
