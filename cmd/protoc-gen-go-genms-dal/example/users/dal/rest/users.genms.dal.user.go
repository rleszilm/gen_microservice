// Package rest_dal_users is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package rest_dal_users

import (
	context "context"
	json "encoding/json"
	users "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users"
	dal "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users/dal"
	stats "go.opencensus.io/stats"
	view "go.opencensus.io/stats/view"
	tag "go.opencensus.io/tag"
	ioutil "io/ioutil"
	log "log"
	http "net/http"
	url "net/url"
	sync "sync"
	time "time"
)

// UserCollection is an autogenerated implementation of dal.UserCollection.
type UserCollection struct {
	dal.UnimplementedUserCollection

	client *http.Client
	config *UserConfig

	queryById              string
	queryByNameAndDivision string
	queryByKind            string
	queryByPhone           string
	queryProviderStubOnly  string
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *UserCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *UserCollection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *UserCollection) NameOf() string {
	return "rest_dal_users_" + x.config.Name
}

// String returns a string identifier for the service.
func (x *UserCollection) String() string {
	return x.NameOf()
}

// All implements dal.UserCollection.All
func (x *UserCollection) All(ctx context.Context) ([]*users.User, error) {
	scheme, method, host, path, headers, _, _ := x.queries.All()

	url := url.URL{
		Scheme: scheme,
		Host:   host,
		Path:   path,
	}

	req, err := http.NewRequest(method, url.String(), nil)
	if err != nil {
		return nil, err
	}

	for k, v := range headers {
		req.Header.Add(k, v)
	}

	return x.find(ctx, "all", req)
}

func (x *UserCollection) find(ctx context.Context, label string, req *http.Request) ([]*users.User, error) {
	var err error
	start := time.Now()
	stats.Record(ctx, userInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, err = tag.New(ctx,
				tag.Upsert(userQueryError, label),
			)
		}

		ctx, err = tag.New(ctx,
			tag.Upsert(userQueryName, label),
		)

		stats.Record(ctx, userLatency.M(dur), userInflight.M(-1))
	}()

	resp, err := x.client.Do(req.WithContext(ctx))
	if err != nil {
		return nil, err
	}

	buff, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	Users := []*users.User{}
	if err := json.Unmarshal(buff, &Users); err != nil {
		return nil, err
	}
	return Users, nil
}

// UserConfig is a struct that can be used to configure a UserCollection
type UserConfig struct {
	Name    string            `envconfig:"name"`
	Timeout time.Duration     `envconfig:"timeout" default:"5s"`
	Headers map[string]string `envconfig:"headers"`
}

// define metrics
var (
	userQueryName  = tag.MustNewKey("dal_rest_user")
	userQueryCode  = tag.MustNewKey("dal_rest_user_code")
	userQueryError = tag.MustNewKey("dal_rest_user_error")

	userLatency  = stats.Float64("user_latency", "Latency of User queries", stats.UnitMilliseconds)
	userInflight = stats.Int64("user_inflight", "Count of User queries in flight", stats.UnitDimensionless)

	registerUserMetricsOnce sync.Once
)

func registerUserMetrics() {
	views := []*view.View{
		{
			Name:        "dal_rest_user_latency",
			Measure:     userLatency,
			Description: "The distribution of the query latencies",
			TagKeys:     []tag.Key{userQueryName, userQueryCode, userQueryError},
			Aggregation: view.Distribution(0, 25, 100, 200, 400, 800, 10000),
		},
		{
			Name:        "dal_rest_user_inflight",
			Measure:     userInflight,
			Description: "The number of queries being processed",
			TagKeys:     []tag.Key{userQueryName, userQueryCode},
			Aggregation: view.Sum(),
		},
	}

	if err := view.Register(views...); err != nil {
		log.Fatal("Cannot register metrics:", err)
	}
}
