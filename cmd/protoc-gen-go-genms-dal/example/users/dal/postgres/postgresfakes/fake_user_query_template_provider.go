// Code generated by counterfeiter. DO NOT EDIT.
package postgresfakes

import (
	"sync"

	postgres_dal_users "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users/dal/postgres"
)

type FakeUserQueryTemplateProvider struct {
	AllStub        func() string
	allMutex       sync.RWMutex
	allArgsForCall []struct {
	}
	allReturns struct {
		result1 string
	}
	allReturnsOnCall map[int]struct {
		result1 string
	}
	ByIdStub        func() string
	byIdMutex       sync.RWMutex
	byIdArgsForCall []struct {
	}
	byIdReturns struct {
		result1 string
	}
	byIdReturnsOnCall map[int]struct {
		result1 string
	}
	ByKindStub        func() string
	byKindMutex       sync.RWMutex
	byKindArgsForCall []struct {
	}
	byKindReturns struct {
		result1 string
	}
	byKindReturnsOnCall map[int]struct {
		result1 string
	}
	ByNameAndDivisionStub        func() string
	byNameAndDivisionMutex       sync.RWMutex
	byNameAndDivisionArgsForCall []struct {
	}
	byNameAndDivisionReturns struct {
		result1 string
	}
	byNameAndDivisionReturnsOnCall map[int]struct {
		result1 string
	}
	ByPhoneStub        func() string
	byPhoneMutex       sync.RWMutex
	byPhoneArgsForCall []struct {
	}
	byPhoneReturns struct {
		result1 string
	}
	byPhoneReturnsOnCall map[int]struct {
		result1 string
	}
	ByRangeStub        func() string
	byRangeMutex       sync.RWMutex
	byRangeArgsForCall []struct {
	}
	byRangeReturns struct {
		result1 string
	}
	byRangeReturnsOnCall map[int]struct {
		result1 string
	}
	InsertStub        func() string
	insertMutex       sync.RWMutex
	insertArgsForCall []struct {
	}
	insertReturns struct {
		result1 string
	}
	insertReturnsOnCall map[int]struct {
		result1 string
	}
	ProviderStubOnlyStub        func() string
	providerStubOnlyMutex       sync.RWMutex
	providerStubOnlyArgsForCall []struct {
	}
	providerStubOnlyReturns struct {
		result1 string
	}
	providerStubOnlyReturnsOnCall map[int]struct {
		result1 string
	}
	UpdateStub        func() string
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
	}
	updateReturns struct {
		result1 string
	}
	updateReturnsOnCall map[int]struct {
		result1 string
	}
	UpsertStub        func() string
	upsertMutex       sync.RWMutex
	upsertArgsForCall []struct {
	}
	upsertReturns struct {
		result1 string
	}
	upsertReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserQueryTemplateProvider) All() string {
	fake.allMutex.Lock()
	ret, specificReturn := fake.allReturnsOnCall[len(fake.allArgsForCall)]
	fake.allArgsForCall = append(fake.allArgsForCall, struct {
	}{})
	fake.recordInvocation("All", []interface{}{})
	fake.allMutex.Unlock()
	if fake.AllStub != nil {
		return fake.AllStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.allReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) AllCallCount() int {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	return len(fake.allArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) AllCalls(stub func() string) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = stub
}

func (fake *FakeUserQueryTemplateProvider) AllReturns(result1 string) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = nil
	fake.allReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) AllReturnsOnCall(i int, result1 string) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = nil
	if fake.allReturnsOnCall == nil {
		fake.allReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.allReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ById() string {
	fake.byIdMutex.Lock()
	ret, specificReturn := fake.byIdReturnsOnCall[len(fake.byIdArgsForCall)]
	fake.byIdArgsForCall = append(fake.byIdArgsForCall, struct {
	}{})
	fake.recordInvocation("ById", []interface{}{})
	fake.byIdMutex.Unlock()
	if fake.ByIdStub != nil {
		return fake.ByIdStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.byIdReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) ByIdCallCount() int {
	fake.byIdMutex.RLock()
	defer fake.byIdMutex.RUnlock()
	return len(fake.byIdArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) ByIdCalls(stub func() string) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = stub
}

func (fake *FakeUserQueryTemplateProvider) ByIdReturns(result1 string) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = nil
	fake.byIdReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByIdReturnsOnCall(i int, result1 string) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = nil
	if fake.byIdReturnsOnCall == nil {
		fake.byIdReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.byIdReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByKind() string {
	fake.byKindMutex.Lock()
	ret, specificReturn := fake.byKindReturnsOnCall[len(fake.byKindArgsForCall)]
	fake.byKindArgsForCall = append(fake.byKindArgsForCall, struct {
	}{})
	fake.recordInvocation("ByKind", []interface{}{})
	fake.byKindMutex.Unlock()
	if fake.ByKindStub != nil {
		return fake.ByKindStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.byKindReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) ByKindCallCount() int {
	fake.byKindMutex.RLock()
	defer fake.byKindMutex.RUnlock()
	return len(fake.byKindArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) ByKindCalls(stub func() string) {
	fake.byKindMutex.Lock()
	defer fake.byKindMutex.Unlock()
	fake.ByKindStub = stub
}

func (fake *FakeUserQueryTemplateProvider) ByKindReturns(result1 string) {
	fake.byKindMutex.Lock()
	defer fake.byKindMutex.Unlock()
	fake.ByKindStub = nil
	fake.byKindReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByKindReturnsOnCall(i int, result1 string) {
	fake.byKindMutex.Lock()
	defer fake.byKindMutex.Unlock()
	fake.ByKindStub = nil
	if fake.byKindReturnsOnCall == nil {
		fake.byKindReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.byKindReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByNameAndDivision() string {
	fake.byNameAndDivisionMutex.Lock()
	ret, specificReturn := fake.byNameAndDivisionReturnsOnCall[len(fake.byNameAndDivisionArgsForCall)]
	fake.byNameAndDivisionArgsForCall = append(fake.byNameAndDivisionArgsForCall, struct {
	}{})
	fake.recordInvocation("ByNameAndDivision", []interface{}{})
	fake.byNameAndDivisionMutex.Unlock()
	if fake.ByNameAndDivisionStub != nil {
		return fake.ByNameAndDivisionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.byNameAndDivisionReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) ByNameAndDivisionCallCount() int {
	fake.byNameAndDivisionMutex.RLock()
	defer fake.byNameAndDivisionMutex.RUnlock()
	return len(fake.byNameAndDivisionArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) ByNameAndDivisionCalls(stub func() string) {
	fake.byNameAndDivisionMutex.Lock()
	defer fake.byNameAndDivisionMutex.Unlock()
	fake.ByNameAndDivisionStub = stub
}

func (fake *FakeUserQueryTemplateProvider) ByNameAndDivisionReturns(result1 string) {
	fake.byNameAndDivisionMutex.Lock()
	defer fake.byNameAndDivisionMutex.Unlock()
	fake.ByNameAndDivisionStub = nil
	fake.byNameAndDivisionReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByNameAndDivisionReturnsOnCall(i int, result1 string) {
	fake.byNameAndDivisionMutex.Lock()
	defer fake.byNameAndDivisionMutex.Unlock()
	fake.ByNameAndDivisionStub = nil
	if fake.byNameAndDivisionReturnsOnCall == nil {
		fake.byNameAndDivisionReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.byNameAndDivisionReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByPhone() string {
	fake.byPhoneMutex.Lock()
	ret, specificReturn := fake.byPhoneReturnsOnCall[len(fake.byPhoneArgsForCall)]
	fake.byPhoneArgsForCall = append(fake.byPhoneArgsForCall, struct {
	}{})
	fake.recordInvocation("ByPhone", []interface{}{})
	fake.byPhoneMutex.Unlock()
	if fake.ByPhoneStub != nil {
		return fake.ByPhoneStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.byPhoneReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) ByPhoneCallCount() int {
	fake.byPhoneMutex.RLock()
	defer fake.byPhoneMutex.RUnlock()
	return len(fake.byPhoneArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) ByPhoneCalls(stub func() string) {
	fake.byPhoneMutex.Lock()
	defer fake.byPhoneMutex.Unlock()
	fake.ByPhoneStub = stub
}

func (fake *FakeUserQueryTemplateProvider) ByPhoneReturns(result1 string) {
	fake.byPhoneMutex.Lock()
	defer fake.byPhoneMutex.Unlock()
	fake.ByPhoneStub = nil
	fake.byPhoneReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByPhoneReturnsOnCall(i int, result1 string) {
	fake.byPhoneMutex.Lock()
	defer fake.byPhoneMutex.Unlock()
	fake.ByPhoneStub = nil
	if fake.byPhoneReturnsOnCall == nil {
		fake.byPhoneReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.byPhoneReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByRange() string {
	fake.byRangeMutex.Lock()
	ret, specificReturn := fake.byRangeReturnsOnCall[len(fake.byRangeArgsForCall)]
	fake.byRangeArgsForCall = append(fake.byRangeArgsForCall, struct {
	}{})
	fake.recordInvocation("ByRange", []interface{}{})
	fake.byRangeMutex.Unlock()
	if fake.ByRangeStub != nil {
		return fake.ByRangeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.byRangeReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) ByRangeCallCount() int {
	fake.byRangeMutex.RLock()
	defer fake.byRangeMutex.RUnlock()
	return len(fake.byRangeArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) ByRangeCalls(stub func() string) {
	fake.byRangeMutex.Lock()
	defer fake.byRangeMutex.Unlock()
	fake.ByRangeStub = stub
}

func (fake *FakeUserQueryTemplateProvider) ByRangeReturns(result1 string) {
	fake.byRangeMutex.Lock()
	defer fake.byRangeMutex.Unlock()
	fake.ByRangeStub = nil
	fake.byRangeReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ByRangeReturnsOnCall(i int, result1 string) {
	fake.byRangeMutex.Lock()
	defer fake.byRangeMutex.Unlock()
	fake.ByRangeStub = nil
	if fake.byRangeReturnsOnCall == nil {
		fake.byRangeReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.byRangeReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) Insert() string {
	fake.insertMutex.Lock()
	ret, specificReturn := fake.insertReturnsOnCall[len(fake.insertArgsForCall)]
	fake.insertArgsForCall = append(fake.insertArgsForCall, struct {
	}{})
	fake.recordInvocation("Insert", []interface{}{})
	fake.insertMutex.Unlock()
	if fake.InsertStub != nil {
		return fake.InsertStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.insertReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) InsertCallCount() int {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return len(fake.insertArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) InsertCalls(stub func() string) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = stub
}

func (fake *FakeUserQueryTemplateProvider) InsertReturns(result1 string) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	fake.insertReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) InsertReturnsOnCall(i int, result1 string) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	if fake.insertReturnsOnCall == nil {
		fake.insertReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.insertReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ProviderStubOnly() string {
	fake.providerStubOnlyMutex.Lock()
	ret, specificReturn := fake.providerStubOnlyReturnsOnCall[len(fake.providerStubOnlyArgsForCall)]
	fake.providerStubOnlyArgsForCall = append(fake.providerStubOnlyArgsForCall, struct {
	}{})
	fake.recordInvocation("ProviderStubOnly", []interface{}{})
	fake.providerStubOnlyMutex.Unlock()
	if fake.ProviderStubOnlyStub != nil {
		return fake.ProviderStubOnlyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.providerStubOnlyReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) ProviderStubOnlyCallCount() int {
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	return len(fake.providerStubOnlyArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) ProviderStubOnlyCalls(stub func() string) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = stub
}

func (fake *FakeUserQueryTemplateProvider) ProviderStubOnlyReturns(result1 string) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = nil
	fake.providerStubOnlyReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) ProviderStubOnlyReturnsOnCall(i int, result1 string) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = nil
	if fake.providerStubOnlyReturnsOnCall == nil {
		fake.providerStubOnlyReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.providerStubOnlyReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) Update() string {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
	}{})
	fake.recordInvocation("Update", []interface{}{})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) UpdateCalls(stub func() string) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeUserQueryTemplateProvider) UpdateReturns(result1 string) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) UpdateReturnsOnCall(i int, result1 string) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) Upsert() string {
	fake.upsertMutex.Lock()
	ret, specificReturn := fake.upsertReturnsOnCall[len(fake.upsertArgsForCall)]
	fake.upsertArgsForCall = append(fake.upsertArgsForCall, struct {
	}{})
	fake.recordInvocation("Upsert", []interface{}{})
	fake.upsertMutex.Unlock()
	if fake.UpsertStub != nil {
		return fake.UpsertStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.upsertReturns
	return fakeReturns.result1
}

func (fake *FakeUserQueryTemplateProvider) UpsertCallCount() int {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	return len(fake.upsertArgsForCall)
}

func (fake *FakeUserQueryTemplateProvider) UpsertCalls(stub func() string) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = stub
}

func (fake *FakeUserQueryTemplateProvider) UpsertReturns(result1 string) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	fake.upsertReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) UpsertReturnsOnCall(i int, result1 string) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	if fake.upsertReturnsOnCall == nil {
		fake.upsertReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.upsertReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserQueryTemplateProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	fake.byIdMutex.RLock()
	defer fake.byIdMutex.RUnlock()
	fake.byKindMutex.RLock()
	defer fake.byKindMutex.RUnlock()
	fake.byNameAndDivisionMutex.RLock()
	defer fake.byNameAndDivisionMutex.RUnlock()
	fake.byPhoneMutex.RLock()
	defer fake.byPhoneMutex.RUnlock()
	fake.byRangeMutex.RLock()
	defer fake.byRangeMutex.RUnlock()
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserQueryTemplateProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ postgres_dal_users.UserQueryTemplateProvider = new(FakeUserQueryTemplateProvider)
