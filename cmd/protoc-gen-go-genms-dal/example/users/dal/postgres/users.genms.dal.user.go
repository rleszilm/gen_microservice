// Package postgres_dal_users is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package postgres_dal_users

import (
	context "context"
	sql1 "database/sql"
	types "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/annotations/types"
	users "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users"
	dal "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users/dal"
	sql "github.com/rleszilm/genms/sql"
	stats "go.opencensus.io/stats"
	view "go.opencensus.io/stats/view"
	tag "go.opencensus.io/tag"
	latlng "google.golang.org/genproto/googleapis/type/latlng"
	log "log"
	sync "sync"
)

// UserCollection is an autogenerated implementation of dal.UserCollection.
type UserCollection struct {
	dal.UnimplementedUserCollection

	db     sql.DB
	config *UserConfig

	execInsert string
	execUpsert string
	queryAll   string

	queryById              string
	queryByNameAndDivision string
	queryByKind            string
	queryByPhone           string
	queryProviderStubOnly  string
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *UserCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *UserCollection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *UserCollection) NameOf() string {
	return "postgres_dal_users_" + x.config.TableName
}

// String returns a string identifier for the service.
func (x *UserCollection) String() string {
	return x.NameOf()
}

// UserFilter is an autogenerated struct that
// is used in generic User queries.
type UserFilter struct {
	Id            *int64   `db:"id"`
	Name          *string  `db:"name"`
	Division      *string  `db:"division"`
	LifetimeScore *float64 `db:"lifetime_score"`
	LastScore     *float32 `db:"last_score"`

	LastWinnings *int32           `db:"payout"`
	Point        *types.Point     `db:"point"`
	Phone        *types.Phone     `db:"phone"`
	Geo          *latlng.LatLng   `db:"geo"`
	Kind         *users.User_Kind `db:"type"`
	ByBackend    *string          `db:"by_backend_rest"`
}

func (x *UserFilter) fromGeneric(y *dal.UserFilter) {
	if y.Id != nil {
		x.Id = y.Id
	}
	if y.Name != nil {
		x.Name = y.Name
	}
	if y.Division != nil {
		x.Division = y.Division
	}
	if y.LifetimeScore != nil {
		x.LifetimeScore = y.LifetimeScore
	}
	if y.LastScore != nil {
		x.LastScore = y.LastScore
	}

	if y.LastWinnings != nil {
		x.LastWinnings = y.LastWinnings
	}
	if y.Point != nil {
		x.Point = y.Point
	}
	if y.Phone != nil {
		x.Phone = y.Phone
	}
	if y.Geo != nil {
		x.Geo = y.Geo
	}
	if y.Kind != nil {
		x.Kind = y.Kind
	}
	if y.ByBackend != nil {
		x.ByBackend = y.ByBackend
	}
}

// UserScanner is an autogenerated struct that
// is used to parse query results.
type UserScanner struct {
	Id            sql1.NullInt64
	Name          sql1.NullString
	Division      sql1.NullString
	LifetimeScore sql1.NullFloat64
	LastScore     sql1.NullFloat64

	LastWinnings sql1.NullInt32
	Point        *types.Point
	Phone        *types.Phone
	Geo          *latlng.LatLng
	Kind         sql1.NullInt32
	ByBackend    sql1.NullString
}

// UserConfig is a struct that can be used to configure a UserCollection
type UserConfig struct {
	TableName string `envconfig:"table"`
}

// define metrics
var (
	userQueryName  = tag.MustNewKey("dal_postgres_user")
	userQueryError = tag.MustNewKey("dal_postgres_user_error")

	userLatency  = stats.Float64("user_latency", "Latency of User queries", stats.UnitMilliseconds)
	userInflight = stats.Int64("user_inflight", "Count of User queries in flight", stats.UnitDimensionless)

	registerUserMetricsOnce sync.Once
)

func registerUserMetrics() {
	views := []*view.View{
		{
			Name:        "dal_postgres_user_latency",
			Measure:     userLatency,
			Description: "The distribution of the query latencies",
			TagKeys:     []tag.Key{userQueryName, userQueryError},
			Aggregation: view.Distribution(0, 25, 100, 200, 400, 800, 10000),
		},
		{
			Name:        "dal_postgres_user_inflight",
			Measure:     userInflight,
			Description: "The number of queries being processed",
			TagKeys:     []tag.Key{userQueryName},
			Aggregation: view.Sum(),
		},
	}

	if err := view.Register(views...); err != nil {
		log.Fatal("Cannot register metrics:", err)
	}
}
