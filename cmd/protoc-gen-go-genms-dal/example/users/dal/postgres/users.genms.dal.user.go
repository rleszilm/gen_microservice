// Package postgres_dal_users is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package postgres_dal_users

import (
	context "context"
	sql2 "database/sql"
	fmt "fmt"
	types "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/annotations/types"
	users "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/example/users"
	dal "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/example/users/dal"
	sql1 "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/generator/sql"
	sql "github.com/rleszilm/gen_microservice/sql"
	stats "go.opencensus.io/stats"
	view "go.opencensus.io/stats/view"
	tag "go.opencensus.io/tag"
	latlng "google.golang.org/genproto/googleapis/type/latlng"
	log "log"
	strings "strings"
	sync "sync"
	time "time"
)

// UserCollection is an autogenerated implementation of dal.UserCollection.
type UserCollection struct {
	dal.UnimplementedUserCollection

	db     sql.DB
	config *UserConfig

	execUpsert string
	queryAll   string

	queryById              string
	queryByNameAndDivision string
	queryByKind            string
	queryByPhone           string
	queryProviderStubOnly  string
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *UserCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *UserCollection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *UserCollection) NameOf() string {
	return "postgres_dal_users_" + x.config.TableName
}

// String returns a string identifier for the service.
func (x *UserCollection) String() string {
	return x.NameOf()
}

// Upsert implements dal.UserCollection.Upsert
func (x *UserCollection) Upsert(ctx context.Context, arg *users.User) (*users.User, error) {
	var err error
	start := time.Now()
	stats.Record(ctx, userInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, err = tag.New(ctx,
				tag.Upsert(userQueryError, "user_upsert"),
			)
		}

		ctx, err = tag.New(ctx,
			tag.Upsert(userQueryName, "user_upsert"),
		)

		stats.Record(ctx, userLatency.M(dur), userInflight.M(-1))
	}()

	if _, err = x.db.ExecWithReplacements(ctx, x.execUpsert, arg); err != nil {
		return nil, err
	}

	return arg, nil
}

// All implements dal.UserCollection.All
func (x *UserCollection) All(ctx context.Context) ([]*users.User, error) {
	filter := &dal.UserFields{}
	return x.find(ctx, "all", x.queryAll, filter)
}

// Filter implements dal.UserCollection.Filter
func (x *UserCollection) Filter(ctx context.Context, arg *dal.UserFields) ([]*users.User, error) {
	query := "SELECT id, name, division, lifetime_score, last_score, payout, point, phone, geo, kind, by_backend_postgres FROM " + x.config.TableName
	fields := []string{}

	if arg.Id != nil {
		fields = append(fields, "id = :id")
	}
	if arg.Name != nil {
		fields = append(fields, "name = :name")
	}
	if arg.Division != nil {
		fields = append(fields, "division = :division")
	}
	if arg.LifetimeScore != nil {
		fields = append(fields, "lifetime_score = :lifetime_score")
	}
	if arg.LastScore != nil {
		fields = append(fields, "last_score = :last_score")
	}
	if arg.LastWinnings != nil {
		fields = append(fields, "payout = :payout")
	}
	if arg.Point != nil {
		fields = append(fields, "point = :point")
	}
	if arg.Phone != nil {
		fields = append(fields, "phone = :phone")
	}
	if arg.Geo != nil {
		fields = append(fields, "geo = :geo")
	}
	if arg.Kind != nil {
		fields = append(fields, "kind = :kind")
	}
	if arg.ByBackend != nil {
		fields = append(fields, "by_backend_postgres = :by_backend_postgres")
	}

	if len(fields) > 0 {
		query = fmt.Sprintf("%s WHERE %s", query, strings.Join(fields, " AND "))
	}

	return x.find(ctx, "filter", query, arg)
}

func (x *UserCollection) find(ctx context.Context, label string, query string, arg *dal.UserFields) ([]*users.User, error) {
	var err error
	start := time.Now()
	stats.Record(ctx, userInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, err = tag.New(ctx,
				tag.Upsert(userQueryError, label),
			)
		}

		ctx, err = tag.New(ctx,
			tag.Upsert(userQueryName, label),
		)

		stats.Record(ctx, userLatency.M(dur), userInflight.M(-1))
	}()

	rows, err := x.db.Query(ctx, query, arg)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	Users := []*users.User{}
	for rows.Next() {
		obj := &UserScanner{}
		if err = rows.StructScan(obj); err != nil {
			return nil, err
		}
		Users = append(Users, obj.User())
	}
	return Users, nil
}

// ById implements dal.UserCollection.ById
func (x *UserCollection) ById(ctx context.Context, id int64) ([]*users.User, error) {
	filter := &dal.UserFields{
		Id: &id,
	}
	return x.find(ctx, "by_id", x.queryById, filter)
}

// ByNameAndDivision implements dal.UserCollection.ByNameAndDivision
func (x *UserCollection) ByNameAndDivision(ctx context.Context, name string, division string) ([]*users.User, error) {
	filter := &dal.UserFields{
		Name:     &name,
		Division: &division,
	}
	return x.find(ctx, "by_name_and_division", x.queryByNameAndDivision, filter)
}

// ByKind implements dal.UserCollection.ByKind
func (x *UserCollection) ByKind(ctx context.Context, kind users.User_Kind) ([]*users.User, error) {
	filter := &dal.UserFields{
		Kind: &kind,
	}
	return x.find(ctx, "by_kind", x.queryByKind, filter)
}

// ByPhone implements dal.UserCollection.ByPhone
func (x *UserCollection) ByPhone(ctx context.Context, phone *types.Phone) ([]*users.User, error) {
	filter := &dal.UserFields{
		Phone: phone,
	}
	return x.find(ctx, "by_phone", x.queryByPhone, filter)
}

// ProviderStubOnly implements dal.UserCollection.ProviderStubOnly
func (x *UserCollection) ProviderStubOnly(ctx context.Context) ([]*users.User, error) {
	filter := &dal.UserFields{}
	return x.find(ctx, "provider_stub_only", x.queryProviderStubOnly, filter)
}

// NewUserCollection returns a new UserCollection.
func NewUserCollection(db sql.DB, queries UserQueryTemplateProvider, config *UserConfig) (*UserCollection, error) {
	registerUserMetricsOnce.Do(registerUserMetrics)

	coll := &UserCollection{
		UnimplementedUserCollection: dal.UnimplementedUserCollection{},
		db:                          db,
		config:                      config,
	}

	queryReplacements := map[string]string{
		"table":  config.TableName,
		"fields": "id, name, division, lifetime_score, last_score, payout, point, phone, geo, kind, by_backend_postgres",
	}

	// generate Upsert exec
	coll.execUpsert = sql1.MustGenerateQuery("dal.User-Exec-Upsert", queries.Upsert(), queryReplacements)

	// generate All query
	coll.queryAll = sql1.MustGenerateQuery("dal.User-Query-All", queries.All(), queryReplacements)

	// generate ById query
	coll.queryById = sql1.MustGenerateQuery("dal.User-Query-ById", queries.ById(), queryReplacements)

	// generate ByNameAndDivision query
	coll.queryByNameAndDivision = sql1.MustGenerateQuery("dal.User-Query-ByNameAndDivision", queries.ByNameAndDivision(), queryReplacements)

	// generate ByKind query
	coll.queryByKind = sql1.MustGenerateQuery("dal.User-Query-ByKind", queries.ByKind(), queryReplacements)

	// generate ByPhone query
	coll.queryByPhone = sql1.MustGenerateQuery("dal.User-Query-ByPhone", queries.ByPhone(), queryReplacements)

	// generate ProviderStubOnly query
	coll.queryProviderStubOnly = sql1.MustGenerateQuery("dal.User-Query-ProviderStubOnly", queries.ProviderStubOnly(), queryReplacements)

	return coll, nil
}

// UserScanner is an autogenerated struct that
// is used to parse query results.
type UserScanner struct {
	Id            sql2.NullInt64   `db:"id"`
	Name          sql2.NullString  `db:"name"`
	Division      sql2.NullString  `db:"division"`
	LifetimeScore sql2.NullFloat64 `db:"lifetime_score"`
	LastScore     sql2.NullFloat64 `db:"last_score"`
	LastWinnings  sql2.NullInt32   `db:"payout"`
	Point         *types.Point     `db:"point"`
	Phone         *types.Phone     `db:"phone"`
	Geo           *latlng.LatLng   `db:"geo"`
	Kind          users.User_Kind  `db:"kind"`
	ByBackend     sql2.NullString  `db:"by_backend_postgres"`
}

// User returns a new users.User populated with scanned values.
func (x *UserScanner) User() *users.User {
	return &users.User{
		Id:            x.Id.Int64,
		Name:          x.Name.String,
		Division:      x.Division.String,
		LifetimeScore: x.LifetimeScore.Float64,
		LastScore:     float32(x.LastScore.Float64),
		LastWinnings:  x.LastWinnings.Int32,
		Point:         x.Point,
		Phone:         x.Phone,
		Geo:           x.Geo,
		Kind:          x.Kind,
		ByBackend:     x.ByBackend.String,
	}
}

// UserConfig is a struct that can be used to configure a UserCollection
type UserConfig struct {
	TableName  string `envconfig:"table"`
	ExecUpsert string
}

// UserQueryTemplateProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
type UserQueryTemplateProvider interface {
	Upsert() string
	All() string
	ById() string
	ByNameAndDivision() string
	ByKind() string
	ByPhone() string
	ProviderStubOnly() string
}

// UserQueries provides auto-generated queries when possible. This is not gauranteed to be a complete
// implementation of the interface. This should be used as a base for the actual query provider used.
type UserQueries struct {
}

// All implements UserQueryTemplateProvider.All.
func (x *UserQueries) All() string {
	return `SELECT id, name, division, lifetime_score, last_score, payout, point, phone, geo, kind, by_backend_postgres FROM {{ table }};`
}

// ById implements UserQueryTemplateProvider.ById.
func (x *UserQueries) ById() string {
	return `SELECT {{ fields }} FROM {{ table }}
		WHERE 
			id = :id;`
}

// ByNameAndDivision implements UserQueryTemplateProvider.ByNameAndDivision.
func (x *UserQueries) ByNameAndDivision() string {
	return `SELECT {{ fields }} FROM {{ table }}
		WHERE 
			name = :name AND
			division = :division;`
}

// ByKind implements UserQueryTemplateProvider.ByKind.
func (x *UserQueries) ByKind() string {
	return `SELECT {{ fields }} FROM {{ table }}
		WHERE 
			kind = :kind;`
}

// ByPhone implements UserQueryTemplateProvider.ByPhone.
func (x *UserQueries) ByPhone() string {
	return `SELECT {{ fields }} FROM {{ table }}
		WHERE 
			phone = :phone;`
}

// define metrics
var (
	userQueryName  = tag.MustNewKey("dal_postgres_user")
	userQueryError = tag.MustNewKey("dal_postgres_user_error")

	userLatency  = stats.Float64("user_latency", "Latency of User queries", stats.UnitMilliseconds)
	userInflight = stats.Int64("user_inflight", "Count of User queries in flight", stats.UnitDimensionless)

	registerUserMetricsOnce sync.Once
)

func registerUserMetrics() {
	views := []*view.View{
		{
			Name:        "dal_postgres_user_latency",
			Measure:     userLatency,
			Description: "The distribution of the query latencies",
			TagKeys:     []tag.Key{userQueryName, userQueryError},
			Aggregation: view.Distribution(0, 25, 100, 200, 400, 800, 10000),
		},
		{
			Name:        "dal_postgres_user_inflight",
			Measure:     userInflight,
			Description: "The number of queries being processed",
			TagKeys:     []tag.Key{userQueryName},
			Aggregation: view.Sum(),
		},
	}

	if err := view.Register(views...); err != nil {
		log.Fatal("Cannot register metrics:", err)
	}
}
