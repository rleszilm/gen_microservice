// Package postgres_dal_users is generated by protoc-gen-go-gsnms-dal. *DO NOT EDIT*
package postgres_dal_users

import (
	users "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/example/users"
)

import (
	"bytes"
	"context"
	sqllib "database/sql"
	"fmt"
	"log"
	"sync"
	"time"
	"text/template"

	dal_users "github.com/rleszilm/gen_microservice/cmd/protoc-gen-go-genms-dal/example/users/dal"
	"github.com/rleszilm/gen_microservice/sql"
	"go.opencensus.io/stats"
	"go.opencensus.io/stats/view"
	"go.opencensus.io/tag"
)

// UserCollection is an autogenerated implementation of
// dal_users.UserCollection.
type UserCollection struct {
	dal_users.UnimplementedUserCollection

	db     sql.DB
	config *UserConfig

	Id            int64
	Name          string
	Division      string
	LifetimeScore float64
	LastScore     float32
	LastWinnings  int32

	execUpsert             string
	queryAll               string
	queryById              string
	queryByNameAndDivision string
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *UserCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *UserCollection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *UserCollection) NameOf() string {
	return "postgres_dal_users_" + x.config.TableName
}

// String returns a string identifier for the service.
func (x *UserCollection) String() string {
	return x.NameOf()
}

// Upsert implements dal_users.UserCollection.Upsert
func (x *UserCollection) Upsert(ctx context.Context, arg *users.User) (*users.User, error) {
	var err error
	start := time.Now()
	stats.Record(ctx, userInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, err = tag.New(ctx,
				tag.Upsert(userQueryError, "user_upsert"),
			)
		}

		ctx, err = tag.New(ctx,
			tag.Upsert(userQueryName, "user_upsert"),
		)

		stats.Record(ctx, userLatency.M(dur), userInflight.M(-1))
	}()

	if _, err = x.db.Exec(ctx, x.config.ExecUpsert, arg); err != nil {
		return nil, err
	}

	return arg, nil
}

// All implements dal_users.UserCollection.All
func (x *UserCollection) All(ctx context.Context) ([]*users.User, error) {
	filter := &dal_users.UserFields{}
	return x.find(ctx, "all", x.queryAll, filter)
}

// Filter implements dal_users.UserCollection.Filter
func (x *UserCollection) Filter(ctx context.Context, arg *dal_users.UserFields) ([]*users.User, error) {
	query := "SELECT id, name, division, lifetime_score, last_score, payout FROM " + x.config.TableName
	fields := ""

	if arg.Id != nil {
		fields += "id = :id AND "
	}
	if arg.Name != nil {
		fields += "name = :name AND "
	}
	if arg.Division != nil {
		fields += "division = :division AND "
	}
	if arg.LifetimeScore != nil {
		fields += "lifetime_score = :lifetime_score AND "
	}
	if arg.LastScore != nil {
		fields += "last_score = :last_score AND "
	}
	if arg.LastWinnings != nil {
		fields += "last_winnings = :last_winnings AND "
	}

	if fields != "" {
		query = fmt.Sprintf("%s WHERE %s 1=1", query, fields)
	}

	return x.find(ctx, "filter", query, arg)
}

// ById implements dal_users.UserCollection.ById
func (x *UserCollection) ById(ctx context.Context, id int64) ([]*users.User, error) {
	filter := &dal_users.UserFields{
		Id: &id,
	}
	return x.find(ctx, "by_id", x.queryById, filter)
}

// ByNameAndDivision implements dal_users.UserCollection.ByNameAndDivision
func (x *UserCollection) ByNameAndDivision(ctx context.Context, name string, division string) ([]*users.User, error) {
	filter := &dal_users.UserFields{
		Name:     &name,
		Division: &division,
	}
	return x.find(ctx, "by_name_and_division", x.queryByNameAndDivision, filter)
}

func (x *UserCollection) find(ctx context.Context, label string, query string, arg *dal_users.UserFields) ([]*users.User, error) {
	var err error
	start := time.Now()
	stats.Record(ctx, userInflight.M(1))
	defer func() {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)

		if err != nil {
			ctx, err = tag.New(ctx,
				tag.Upsert(userQueryError, label),
			)
		}

		ctx, err = tag.New(ctx,
			tag.Upsert(userQueryName, label),
		)

		stats.Record(ctx, userLatency.M(dur), userInflight.M(-1))
	}()

	rows, err := x.db.Query(ctx, query, arg)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	Users := []*users.User{}
	for rows.Next() {
		obj := &UserScanner{}
		if err = rows.StructScan(obj); err != nil {
			return nil, err
		}
		Users = append(Users, obj.User())
	}
	return Users, nil
}

// NewUserCollection returns a new UserCollection.
func NewUserCollection(db sql.DB, queries UserQueryTemplateProvider, config *UserConfig) (*UserCollection, error) {
	registerUserMetricsOnce.Do(registerUserMetrics)

	coll := &UserCollection{
		UnimplementedUserCollection: dal_users.UnimplementedUserCollection{},
		db:                          db,
		config:                      config,
	}

	queryReplacements := map[string]string{
		"table":  config.TableName,
		"fields": "id, name, division, lifetime_score, last_score, payout",
	}

	// generate Upsert exec
	if queries.Upsert() != "" {
		tmpl, err := template.New("execUpsert").Parse(queries.All())
		if err != nil {
			return nil, err
		}

		buf := &bytes.Buffer{}
		if err := tmpl.Execute(buf, queryReplacements); err != nil {
			return nil, err
		}
		coll.execUpsert = string(buf.Bytes())
	}

	// generate All query
	if queries.All() != "" {
		tmpl, err := template.New("queryAll").Parse(queries.All())
		if err != nil {
			return nil, err
		}

		buf := &bytes.Buffer{}
		if err := tmpl.Execute(buf, queryReplacements); err != nil {
			return nil, err
		}
		coll.queryAll = string(buf.Bytes())
	}

	// generate ById query
	if queries.ById() != "" {
		tmpl, err := template.New("queryById").Parse(queries.ById())
		if err != nil {
			return nil, err
		}

		buf := &bytes.Buffer{}
		if err := tmpl.Execute(buf, queryReplacements); err != nil {
			return nil, err
		}
		coll.queryById = string(buf.Bytes())
	}

	// generate ByNameAndDivision query
	if queries.ByNameAndDivision() != "" {
		tmpl, err := template.New("queryByNameAndDivision").Parse(queries.ByNameAndDivision())
		if err != nil {
			return nil, err
		}

		buf := &bytes.Buffer{}
		if err := tmpl.Execute(buf, queryReplacements); err != nil {
			return nil, err
		}
		coll.queryByNameAndDivision = string(buf.Bytes())
	}

	return coll, nil
}

// UserScanner is an autogenerated struct that
// is used to parse query results.
type UserScanner struct {
	Id            sqllib.NullInt64   `db:"id"`
	Name          sqllib.NullString  `db:"name"`
	Division      sqllib.NullString  `db:"division"`
	LifetimeScore sqllib.NullFloat64 `db:"lifetime_score"`
	LastScore     sqllib.NullFloat64 `db:"last_score"`
	LastWinnings  sqllib.NullInt32   `db:"payout"`
}

// User returns a new users.User populated with scanned values.
func (x *UserScanner) User() *users.User {
	return &users.User{
		Id:            x.Id.Int64,
		Name:          x.Name.String,
		Division:      x.Division.String,
		LifetimeScore: x.LifetimeScore.Float64,
		LastScore:     float32(x.LastScore.Float64),
		LastWinnings:  x.LastWinnings.Int32,
	}
}

// UserConfig is a struct that can be used to configure a UserCollection
type UserConfig struct {
	TableName  string `envconfig:"table"`
	ExecUpsert string
}

// UserQueryTemplateProvider is an interface that returns the query templated that should be executed
// to generate the queries that the collection will use.
type UserQueryTemplateProvider interface {
	Upsert() string
	All() string
	ById() string
	ByNameAndDivision() string
}

// UserQueries provides auto-generated queries when possible. This is not gauranteed to be a complete
// implementation of the interface. This should be used as a base for the actual query provider used.
type UserQueries struct {
}

// All implements UserQueryTemplateProvider.All.
func (x *UserQueries) All() string {
	return `SELECT id, name, division, lifetime_score, last_score, payout FROM {{ table }};`
}

// ById implements UserQueryTemplateProvider.ById.
func (x *UserQueries) ById() string {
	return `SELECT {{ fields }} FROM {{ table }}
				WHERE 
					id = :id AND
					1 = 1;`
}

// ByNameAndDivision implements UserQueryTemplateProvider.ByNameAndDivision.
func (x *UserQueries) ByNameAndDivision() string {
	return `SELECT {{ fields }} FROM {{ table }}
				WHERE 
					name = :name AND
					division = :division AND
					1 = 1;`
}

// define metrics
var (
	userQueryName  = tag.MustNewKey("postgres_dal_user")
	userQueryError = tag.MustNewKey("postgres_dal_user_error")

	userLatency  = stats.Float64("user_latency", "Latency of User queries", stats.UnitMilliseconds)
	userInflight = stats.Int64("user_inflight", "Count of User queries in flight", stats.UnitDimensionless)

	registerUserMetricsOnce sync.Once
)

func registerUserMetrics() {
	views := []*view.View{
		{
			Name:        "user_latency",
			Measure:     userLatency,
			Description: "The distribution of the query latencies",
			TagKeys:     []tag.Key{userQueryName, userQueryError},
			Aggregation: view.Distribution(0, 25, 100, 200, 400, 800, 10000),
		},
		{
			Name:        "user_inflight",
			Measure:     userInflight,
			Description: "The number of queries being processed",
			TagKeys:     []tag.Key{userQueryName},
			Aggregation: view.Sum(),
		},
	}

	if err := view.Register(views...); err != nil {
		log.Fatal("Cannot register metrics:", err)
	}
}
