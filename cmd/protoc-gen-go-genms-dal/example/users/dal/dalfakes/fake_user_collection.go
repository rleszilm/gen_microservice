// Code generated by counterfeiter. DO NOT EDIT.
package dalfakes

import (
	"context"
	"sync"

	"github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/annotations/types"
	"github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users"
	dal_users "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/users/dal"
	"github.com/rleszilm/genms/service"
)

type FakeUserCollection struct {
	AllStub        func(context.Context) ([]*users.User, error)
	allMutex       sync.RWMutex
	allArgsForCall []struct {
		arg1 context.Context
	}
	allReturns struct {
		result1 []*users.User
		result2 error
	}
	allReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	ByIdStub        func(context.Context, int64) ([]*users.User, error)
	byIdMutex       sync.RWMutex
	byIdArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	byIdReturns struct {
		result1 []*users.User
		result2 error
	}
	byIdReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	ByKindStub        func(context.Context, users.User_Kind) ([]*users.User, error)
	byKindMutex       sync.RWMutex
	byKindArgsForCall []struct {
		arg1 context.Context
		arg2 users.User_Kind
	}
	byKindReturns struct {
		result1 []*users.User
		result2 error
	}
	byKindReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	ByNameAndDivisionStub        func(context.Context, string, string) ([]*users.User, error)
	byNameAndDivisionMutex       sync.RWMutex
	byNameAndDivisionArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	byNameAndDivisionReturns struct {
		result1 []*users.User
		result2 error
	}
	byNameAndDivisionReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	ByPhoneStub        func(context.Context, *types.Phone) ([]*users.User, error)
	byPhoneMutex       sync.RWMutex
	byPhoneArgsForCall []struct {
		arg1 context.Context
		arg2 *types.Phone
	}
	byPhoneReturns struct {
		result1 []*users.User
		result2 error
	}
	byPhoneReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	ByRangeStub        func(context.Context, int64) ([]*users.User, error)
	byRangeMutex       sync.RWMutex
	byRangeArgsForCall []struct {
		arg1 context.Context
		arg2 int64
	}
	byRangeReturns struct {
		result1 []*users.User
		result2 error
	}
	byRangeReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	DependantsStub        func() service.Services
	dependantsMutex       sync.RWMutex
	dependantsArgsForCall []struct {
	}
	dependantsReturns struct {
		result1 service.Services
	}
	dependantsReturnsOnCall map[int]struct {
		result1 service.Services
	}
	FilterStub        func(context.Context, *dal_users.UserFieldValues) ([]*users.User, error)
	filterMutex       sync.RWMutex
	filterArgsForCall []struct {
		arg1 context.Context
		arg2 *dal_users.UserFieldValues
	}
	filterReturns struct {
		result1 []*users.User
		result2 error
	}
	filterReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	InitializeStub        func(context.Context) error
	initializeMutex       sync.RWMutex
	initializeArgsForCall []struct {
		arg1 context.Context
	}
	initializeReturns struct {
		result1 error
	}
	initializeReturnsOnCall map[int]struct {
		result1 error
	}
	InsertStub        func(context.Context, *users.User) (*users.User, error)
	insertMutex       sync.RWMutex
	insertArgsForCall []struct {
		arg1 context.Context
		arg2 *users.User
	}
	insertReturns struct {
		result1 *users.User
		result2 error
	}
	insertReturnsOnCall map[int]struct {
		result1 *users.User
		result2 error
	}
	InterfaceStubOnlyStub        func(context.Context) ([]*users.User, error)
	interfaceStubOnlyMutex       sync.RWMutex
	interfaceStubOnlyArgsForCall []struct {
		arg1 context.Context
	}
	interfaceStubOnlyReturns struct {
		result1 []*users.User
		result2 error
	}
	interfaceStubOnlyReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	NameOfStub        func() string
	nameOfMutex       sync.RWMutex
	nameOfArgsForCall []struct {
	}
	nameOfReturns struct {
		result1 string
	}
	nameOfReturnsOnCall map[int]struct {
		result1 string
	}
	ProviderStubOnlyStub        func(context.Context) ([]*users.User, error)
	providerStubOnlyMutex       sync.RWMutex
	providerStubOnlyArgsForCall []struct {
		arg1 context.Context
	}
	providerStubOnlyReturns struct {
		result1 []*users.User
		result2 error
	}
	providerStubOnlyReturnsOnCall map[int]struct {
		result1 []*users.User
		result2 error
	}
	ShutdownStub        func(context.Context) error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
		arg1 context.Context
	}
	shutdownReturns struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	StringStub        func() string
	stringMutex       sync.RWMutex
	stringArgsForCall []struct {
	}
	stringReturns struct {
		result1 string
	}
	stringReturnsOnCall map[int]struct {
		result1 string
	}
	UpdateStub        func(context.Context, *users.User, *dal_users.UserFieldValues) (*users.User, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 context.Context
		arg2 *users.User
		arg3 *dal_users.UserFieldValues
	}
	updateReturns struct {
		result1 *users.User
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *users.User
		result2 error
	}
	UpsertStub        func(context.Context, *users.User) (*users.User, error)
	upsertMutex       sync.RWMutex
	upsertArgsForCall []struct {
		arg1 context.Context
		arg2 *users.User
	}
	upsertReturns struct {
		result1 *users.User
		result2 error
	}
	upsertReturnsOnCall map[int]struct {
		result1 *users.User
		result2 error
	}
	WithDependenciesStub        func(...service.Service)
	withDependenciesMutex       sync.RWMutex
	withDependenciesArgsForCall []struct {
		arg1 []service.Service
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeUserCollection) All(arg1 context.Context) ([]*users.User, error) {
	fake.allMutex.Lock()
	ret, specificReturn := fake.allReturnsOnCall[len(fake.allArgsForCall)]
	fake.allArgsForCall = append(fake.allArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("All", []interface{}{arg1})
	fake.allMutex.Unlock()
	if fake.AllStub != nil {
		return fake.AllStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.allReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) AllCallCount() int {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	return len(fake.allArgsForCall)
}

func (fake *FakeUserCollection) AllCalls(stub func(context.Context) ([]*users.User, error)) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = stub
}

func (fake *FakeUserCollection) AllArgsForCall(i int) context.Context {
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	argsForCall := fake.allArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserCollection) AllReturns(result1 []*users.User, result2 error) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = nil
	fake.allReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) AllReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.allMutex.Lock()
	defer fake.allMutex.Unlock()
	fake.AllStub = nil
	if fake.allReturnsOnCall == nil {
		fake.allReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.allReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ById(arg1 context.Context, arg2 int64) ([]*users.User, error) {
	fake.byIdMutex.Lock()
	ret, specificReturn := fake.byIdReturnsOnCall[len(fake.byIdArgsForCall)]
	fake.byIdArgsForCall = append(fake.byIdArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("ById", []interface{}{arg1, arg2})
	fake.byIdMutex.Unlock()
	if fake.ByIdStub != nil {
		return fake.ByIdStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.byIdReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) ByIdCallCount() int {
	fake.byIdMutex.RLock()
	defer fake.byIdMutex.RUnlock()
	return len(fake.byIdArgsForCall)
}

func (fake *FakeUserCollection) ByIdCalls(stub func(context.Context, int64) ([]*users.User, error)) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = stub
}

func (fake *FakeUserCollection) ByIdArgsForCall(i int) (context.Context, int64) {
	fake.byIdMutex.RLock()
	defer fake.byIdMutex.RUnlock()
	argsForCall := fake.byIdArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserCollection) ByIdReturns(result1 []*users.User, result2 error) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = nil
	fake.byIdReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByIdReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.byIdMutex.Lock()
	defer fake.byIdMutex.Unlock()
	fake.ByIdStub = nil
	if fake.byIdReturnsOnCall == nil {
		fake.byIdReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.byIdReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByKind(arg1 context.Context, arg2 users.User_Kind) ([]*users.User, error) {
	fake.byKindMutex.Lock()
	ret, specificReturn := fake.byKindReturnsOnCall[len(fake.byKindArgsForCall)]
	fake.byKindArgsForCall = append(fake.byKindArgsForCall, struct {
		arg1 context.Context
		arg2 users.User_Kind
	}{arg1, arg2})
	fake.recordInvocation("ByKind", []interface{}{arg1, arg2})
	fake.byKindMutex.Unlock()
	if fake.ByKindStub != nil {
		return fake.ByKindStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.byKindReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) ByKindCallCount() int {
	fake.byKindMutex.RLock()
	defer fake.byKindMutex.RUnlock()
	return len(fake.byKindArgsForCall)
}

func (fake *FakeUserCollection) ByKindCalls(stub func(context.Context, users.User_Kind) ([]*users.User, error)) {
	fake.byKindMutex.Lock()
	defer fake.byKindMutex.Unlock()
	fake.ByKindStub = stub
}

func (fake *FakeUserCollection) ByKindArgsForCall(i int) (context.Context, users.User_Kind) {
	fake.byKindMutex.RLock()
	defer fake.byKindMutex.RUnlock()
	argsForCall := fake.byKindArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserCollection) ByKindReturns(result1 []*users.User, result2 error) {
	fake.byKindMutex.Lock()
	defer fake.byKindMutex.Unlock()
	fake.ByKindStub = nil
	fake.byKindReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByKindReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.byKindMutex.Lock()
	defer fake.byKindMutex.Unlock()
	fake.ByKindStub = nil
	if fake.byKindReturnsOnCall == nil {
		fake.byKindReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.byKindReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByNameAndDivision(arg1 context.Context, arg2 string, arg3 string) ([]*users.User, error) {
	fake.byNameAndDivisionMutex.Lock()
	ret, specificReturn := fake.byNameAndDivisionReturnsOnCall[len(fake.byNameAndDivisionArgsForCall)]
	fake.byNameAndDivisionArgsForCall = append(fake.byNameAndDivisionArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	fake.recordInvocation("ByNameAndDivision", []interface{}{arg1, arg2, arg3})
	fake.byNameAndDivisionMutex.Unlock()
	if fake.ByNameAndDivisionStub != nil {
		return fake.ByNameAndDivisionStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.byNameAndDivisionReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) ByNameAndDivisionCallCount() int {
	fake.byNameAndDivisionMutex.RLock()
	defer fake.byNameAndDivisionMutex.RUnlock()
	return len(fake.byNameAndDivisionArgsForCall)
}

func (fake *FakeUserCollection) ByNameAndDivisionCalls(stub func(context.Context, string, string) ([]*users.User, error)) {
	fake.byNameAndDivisionMutex.Lock()
	defer fake.byNameAndDivisionMutex.Unlock()
	fake.ByNameAndDivisionStub = stub
}

func (fake *FakeUserCollection) ByNameAndDivisionArgsForCall(i int) (context.Context, string, string) {
	fake.byNameAndDivisionMutex.RLock()
	defer fake.byNameAndDivisionMutex.RUnlock()
	argsForCall := fake.byNameAndDivisionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserCollection) ByNameAndDivisionReturns(result1 []*users.User, result2 error) {
	fake.byNameAndDivisionMutex.Lock()
	defer fake.byNameAndDivisionMutex.Unlock()
	fake.ByNameAndDivisionStub = nil
	fake.byNameAndDivisionReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByNameAndDivisionReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.byNameAndDivisionMutex.Lock()
	defer fake.byNameAndDivisionMutex.Unlock()
	fake.ByNameAndDivisionStub = nil
	if fake.byNameAndDivisionReturnsOnCall == nil {
		fake.byNameAndDivisionReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.byNameAndDivisionReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByPhone(arg1 context.Context, arg2 *types.Phone) ([]*users.User, error) {
	fake.byPhoneMutex.Lock()
	ret, specificReturn := fake.byPhoneReturnsOnCall[len(fake.byPhoneArgsForCall)]
	fake.byPhoneArgsForCall = append(fake.byPhoneArgsForCall, struct {
		arg1 context.Context
		arg2 *types.Phone
	}{arg1, arg2})
	fake.recordInvocation("ByPhone", []interface{}{arg1, arg2})
	fake.byPhoneMutex.Unlock()
	if fake.ByPhoneStub != nil {
		return fake.ByPhoneStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.byPhoneReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) ByPhoneCallCount() int {
	fake.byPhoneMutex.RLock()
	defer fake.byPhoneMutex.RUnlock()
	return len(fake.byPhoneArgsForCall)
}

func (fake *FakeUserCollection) ByPhoneCalls(stub func(context.Context, *types.Phone) ([]*users.User, error)) {
	fake.byPhoneMutex.Lock()
	defer fake.byPhoneMutex.Unlock()
	fake.ByPhoneStub = stub
}

func (fake *FakeUserCollection) ByPhoneArgsForCall(i int) (context.Context, *types.Phone) {
	fake.byPhoneMutex.RLock()
	defer fake.byPhoneMutex.RUnlock()
	argsForCall := fake.byPhoneArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserCollection) ByPhoneReturns(result1 []*users.User, result2 error) {
	fake.byPhoneMutex.Lock()
	defer fake.byPhoneMutex.Unlock()
	fake.ByPhoneStub = nil
	fake.byPhoneReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByPhoneReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.byPhoneMutex.Lock()
	defer fake.byPhoneMutex.Unlock()
	fake.ByPhoneStub = nil
	if fake.byPhoneReturnsOnCall == nil {
		fake.byPhoneReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.byPhoneReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByRange(arg1 context.Context, arg2 int64) ([]*users.User, error) {
	fake.byRangeMutex.Lock()
	ret, specificReturn := fake.byRangeReturnsOnCall[len(fake.byRangeArgsForCall)]
	fake.byRangeArgsForCall = append(fake.byRangeArgsForCall, struct {
		arg1 context.Context
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("ByRange", []interface{}{arg1, arg2})
	fake.byRangeMutex.Unlock()
	if fake.ByRangeStub != nil {
		return fake.ByRangeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.byRangeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) ByRangeCallCount() int {
	fake.byRangeMutex.RLock()
	defer fake.byRangeMutex.RUnlock()
	return len(fake.byRangeArgsForCall)
}

func (fake *FakeUserCollection) ByRangeCalls(stub func(context.Context, int64) ([]*users.User, error)) {
	fake.byRangeMutex.Lock()
	defer fake.byRangeMutex.Unlock()
	fake.ByRangeStub = stub
}

func (fake *FakeUserCollection) ByRangeArgsForCall(i int) (context.Context, int64) {
	fake.byRangeMutex.RLock()
	defer fake.byRangeMutex.RUnlock()
	argsForCall := fake.byRangeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserCollection) ByRangeReturns(result1 []*users.User, result2 error) {
	fake.byRangeMutex.Lock()
	defer fake.byRangeMutex.Unlock()
	fake.ByRangeStub = nil
	fake.byRangeReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ByRangeReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.byRangeMutex.Lock()
	defer fake.byRangeMutex.Unlock()
	fake.ByRangeStub = nil
	if fake.byRangeReturnsOnCall == nil {
		fake.byRangeReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.byRangeReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) Dependants() service.Services {
	fake.dependantsMutex.Lock()
	ret, specificReturn := fake.dependantsReturnsOnCall[len(fake.dependantsArgsForCall)]
	fake.dependantsArgsForCall = append(fake.dependantsArgsForCall, struct {
	}{})
	fake.recordInvocation("Dependants", []interface{}{})
	fake.dependantsMutex.Unlock()
	if fake.DependantsStub != nil {
		return fake.DependantsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.dependantsReturns
	return fakeReturns.result1
}

func (fake *FakeUserCollection) DependantsCallCount() int {
	fake.dependantsMutex.RLock()
	defer fake.dependantsMutex.RUnlock()
	return len(fake.dependantsArgsForCall)
}

func (fake *FakeUserCollection) DependantsCalls(stub func() service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = stub
}

func (fake *FakeUserCollection) DependantsReturns(result1 service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = nil
	fake.dependantsReturns = struct {
		result1 service.Services
	}{result1}
}

func (fake *FakeUserCollection) DependantsReturnsOnCall(i int, result1 service.Services) {
	fake.dependantsMutex.Lock()
	defer fake.dependantsMutex.Unlock()
	fake.DependantsStub = nil
	if fake.dependantsReturnsOnCall == nil {
		fake.dependantsReturnsOnCall = make(map[int]struct {
			result1 service.Services
		})
	}
	fake.dependantsReturnsOnCall[i] = struct {
		result1 service.Services
	}{result1}
}

func (fake *FakeUserCollection) Filter(arg1 context.Context, arg2 *dal_users.UserFieldValues) ([]*users.User, error) {
	fake.filterMutex.Lock()
	ret, specificReturn := fake.filterReturnsOnCall[len(fake.filterArgsForCall)]
	fake.filterArgsForCall = append(fake.filterArgsForCall, struct {
		arg1 context.Context
		arg2 *dal_users.UserFieldValues
	}{arg1, arg2})
	fake.recordInvocation("Filter", []interface{}{arg1, arg2})
	fake.filterMutex.Unlock()
	if fake.FilterStub != nil {
		return fake.FilterStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.filterReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) FilterCallCount() int {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	return len(fake.filterArgsForCall)
}

func (fake *FakeUserCollection) FilterCalls(stub func(context.Context, *dal_users.UserFieldValues) ([]*users.User, error)) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = stub
}

func (fake *FakeUserCollection) FilterArgsForCall(i int) (context.Context, *dal_users.UserFieldValues) {
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	argsForCall := fake.filterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserCollection) FilterReturns(result1 []*users.User, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	fake.filterReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) FilterReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.filterMutex.Lock()
	defer fake.filterMutex.Unlock()
	fake.FilterStub = nil
	if fake.filterReturnsOnCall == nil {
		fake.filterReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.filterReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) Initialize(arg1 context.Context) error {
	fake.initializeMutex.Lock()
	ret, specificReturn := fake.initializeReturnsOnCall[len(fake.initializeArgsForCall)]
	fake.initializeArgsForCall = append(fake.initializeArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Initialize", []interface{}{arg1})
	fake.initializeMutex.Unlock()
	if fake.InitializeStub != nil {
		return fake.InitializeStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.initializeReturns
	return fakeReturns.result1
}

func (fake *FakeUserCollection) InitializeCallCount() int {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	return len(fake.initializeArgsForCall)
}

func (fake *FakeUserCollection) InitializeCalls(stub func(context.Context) error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = stub
}

func (fake *FakeUserCollection) InitializeArgsForCall(i int) context.Context {
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	argsForCall := fake.initializeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserCollection) InitializeReturns(result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	fake.initializeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserCollection) InitializeReturnsOnCall(i int, result1 error) {
	fake.initializeMutex.Lock()
	defer fake.initializeMutex.Unlock()
	fake.InitializeStub = nil
	if fake.initializeReturnsOnCall == nil {
		fake.initializeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.initializeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserCollection) Insert(arg1 context.Context, arg2 *users.User) (*users.User, error) {
	fake.insertMutex.Lock()
	ret, specificReturn := fake.insertReturnsOnCall[len(fake.insertArgsForCall)]
	fake.insertArgsForCall = append(fake.insertArgsForCall, struct {
		arg1 context.Context
		arg2 *users.User
	}{arg1, arg2})
	fake.recordInvocation("Insert", []interface{}{arg1, arg2})
	fake.insertMutex.Unlock()
	if fake.InsertStub != nil {
		return fake.InsertStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.insertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) InsertCallCount() int {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	return len(fake.insertArgsForCall)
}

func (fake *FakeUserCollection) InsertCalls(stub func(context.Context, *users.User) (*users.User, error)) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = stub
}

func (fake *FakeUserCollection) InsertArgsForCall(i int) (context.Context, *users.User) {
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	argsForCall := fake.insertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserCollection) InsertReturns(result1 *users.User, result2 error) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	fake.insertReturns = struct {
		result1 *users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) InsertReturnsOnCall(i int, result1 *users.User, result2 error) {
	fake.insertMutex.Lock()
	defer fake.insertMutex.Unlock()
	fake.InsertStub = nil
	if fake.insertReturnsOnCall == nil {
		fake.insertReturnsOnCall = make(map[int]struct {
			result1 *users.User
			result2 error
		})
	}
	fake.insertReturnsOnCall[i] = struct {
		result1 *users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) InterfaceStubOnly(arg1 context.Context) ([]*users.User, error) {
	fake.interfaceStubOnlyMutex.Lock()
	ret, specificReturn := fake.interfaceStubOnlyReturnsOnCall[len(fake.interfaceStubOnlyArgsForCall)]
	fake.interfaceStubOnlyArgsForCall = append(fake.interfaceStubOnlyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("InterfaceStubOnly", []interface{}{arg1})
	fake.interfaceStubOnlyMutex.Unlock()
	if fake.InterfaceStubOnlyStub != nil {
		return fake.InterfaceStubOnlyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.interfaceStubOnlyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) InterfaceStubOnlyCallCount() int {
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	return len(fake.interfaceStubOnlyArgsForCall)
}

func (fake *FakeUserCollection) InterfaceStubOnlyCalls(stub func(context.Context) ([]*users.User, error)) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = stub
}

func (fake *FakeUserCollection) InterfaceStubOnlyArgsForCall(i int) context.Context {
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	argsForCall := fake.interfaceStubOnlyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserCollection) InterfaceStubOnlyReturns(result1 []*users.User, result2 error) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = nil
	fake.interfaceStubOnlyReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) InterfaceStubOnlyReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.interfaceStubOnlyMutex.Lock()
	defer fake.interfaceStubOnlyMutex.Unlock()
	fake.InterfaceStubOnlyStub = nil
	if fake.interfaceStubOnlyReturnsOnCall == nil {
		fake.interfaceStubOnlyReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.interfaceStubOnlyReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) NameOf() string {
	fake.nameOfMutex.Lock()
	ret, specificReturn := fake.nameOfReturnsOnCall[len(fake.nameOfArgsForCall)]
	fake.nameOfArgsForCall = append(fake.nameOfArgsForCall, struct {
	}{})
	fake.recordInvocation("NameOf", []interface{}{})
	fake.nameOfMutex.Unlock()
	if fake.NameOfStub != nil {
		return fake.NameOfStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameOfReturns
	return fakeReturns.result1
}

func (fake *FakeUserCollection) NameOfCallCount() int {
	fake.nameOfMutex.RLock()
	defer fake.nameOfMutex.RUnlock()
	return len(fake.nameOfArgsForCall)
}

func (fake *FakeUserCollection) NameOfCalls(stub func() string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = stub
}

func (fake *FakeUserCollection) NameOfReturns(result1 string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = nil
	fake.nameOfReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserCollection) NameOfReturnsOnCall(i int, result1 string) {
	fake.nameOfMutex.Lock()
	defer fake.nameOfMutex.Unlock()
	fake.NameOfStub = nil
	if fake.nameOfReturnsOnCall == nil {
		fake.nameOfReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameOfReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserCollection) ProviderStubOnly(arg1 context.Context) ([]*users.User, error) {
	fake.providerStubOnlyMutex.Lock()
	ret, specificReturn := fake.providerStubOnlyReturnsOnCall[len(fake.providerStubOnlyArgsForCall)]
	fake.providerStubOnlyArgsForCall = append(fake.providerStubOnlyArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("ProviderStubOnly", []interface{}{arg1})
	fake.providerStubOnlyMutex.Unlock()
	if fake.ProviderStubOnlyStub != nil {
		return fake.ProviderStubOnlyStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.providerStubOnlyReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) ProviderStubOnlyCallCount() int {
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	return len(fake.providerStubOnlyArgsForCall)
}

func (fake *FakeUserCollection) ProviderStubOnlyCalls(stub func(context.Context) ([]*users.User, error)) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = stub
}

func (fake *FakeUserCollection) ProviderStubOnlyArgsForCall(i int) context.Context {
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	argsForCall := fake.providerStubOnlyArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserCollection) ProviderStubOnlyReturns(result1 []*users.User, result2 error) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = nil
	fake.providerStubOnlyReturns = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) ProviderStubOnlyReturnsOnCall(i int, result1 []*users.User, result2 error) {
	fake.providerStubOnlyMutex.Lock()
	defer fake.providerStubOnlyMutex.Unlock()
	fake.ProviderStubOnlyStub = nil
	if fake.providerStubOnlyReturnsOnCall == nil {
		fake.providerStubOnlyReturnsOnCall = make(map[int]struct {
			result1 []*users.User
			result2 error
		})
	}
	fake.providerStubOnlyReturnsOnCall[i] = struct {
		result1 []*users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) Shutdown(arg1 context.Context) error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	fake.recordInvocation("Shutdown", []interface{}{arg1})
	fake.shutdownMutex.Unlock()
	if fake.ShutdownStub != nil {
		return fake.ShutdownStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.shutdownReturns
	return fakeReturns.result1
}

func (fake *FakeUserCollection) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakeUserCollection) ShutdownCalls(stub func(context.Context) error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = stub
}

func (fake *FakeUserCollection) ShutdownArgsForCall(i int) context.Context {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	argsForCall := fake.shutdownArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserCollection) ShutdownReturns(result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserCollection) ShutdownReturnsOnCall(i int, result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeUserCollection) String() string {
	fake.stringMutex.Lock()
	ret, specificReturn := fake.stringReturnsOnCall[len(fake.stringArgsForCall)]
	fake.stringArgsForCall = append(fake.stringArgsForCall, struct {
	}{})
	fake.recordInvocation("String", []interface{}{})
	fake.stringMutex.Unlock()
	if fake.StringStub != nil {
		return fake.StringStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.stringReturns
	return fakeReturns.result1
}

func (fake *FakeUserCollection) StringCallCount() int {
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	return len(fake.stringArgsForCall)
}

func (fake *FakeUserCollection) StringCalls(stub func() string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = stub
}

func (fake *FakeUserCollection) StringReturns(result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	fake.stringReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserCollection) StringReturnsOnCall(i int, result1 string) {
	fake.stringMutex.Lock()
	defer fake.stringMutex.Unlock()
	fake.StringStub = nil
	if fake.stringReturnsOnCall == nil {
		fake.stringReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.stringReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeUserCollection) Update(arg1 context.Context, arg2 *users.User, arg3 *dal_users.UserFieldValues) (*users.User, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 context.Context
		arg2 *users.User
		arg3 *dal_users.UserFieldValues
	}{arg1, arg2, arg3})
	fake.recordInvocation("Update", []interface{}{arg1, arg2, arg3})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeUserCollection) UpdateCalls(stub func(context.Context, *users.User, *dal_users.UserFieldValues) (*users.User, error)) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = stub
}

func (fake *FakeUserCollection) UpdateArgsForCall(i int) (context.Context, *users.User, *dal_users.UserFieldValues) {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	argsForCall := fake.updateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeUserCollection) UpdateReturns(result1 *users.User, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) UpdateReturnsOnCall(i int, result1 *users.User, result2 error) {
	fake.updateMutex.Lock()
	defer fake.updateMutex.Unlock()
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *users.User
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) Upsert(arg1 context.Context, arg2 *users.User) (*users.User, error) {
	fake.upsertMutex.Lock()
	ret, specificReturn := fake.upsertReturnsOnCall[len(fake.upsertArgsForCall)]
	fake.upsertArgsForCall = append(fake.upsertArgsForCall, struct {
		arg1 context.Context
		arg2 *users.User
	}{arg1, arg2})
	fake.recordInvocation("Upsert", []interface{}{arg1, arg2})
	fake.upsertMutex.Unlock()
	if fake.UpsertStub != nil {
		return fake.UpsertStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.upsertReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeUserCollection) UpsertCallCount() int {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	return len(fake.upsertArgsForCall)
}

func (fake *FakeUserCollection) UpsertCalls(stub func(context.Context, *users.User) (*users.User, error)) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = stub
}

func (fake *FakeUserCollection) UpsertArgsForCall(i int) (context.Context, *users.User) {
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	argsForCall := fake.upsertArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeUserCollection) UpsertReturns(result1 *users.User, result2 error) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	fake.upsertReturns = struct {
		result1 *users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) UpsertReturnsOnCall(i int, result1 *users.User, result2 error) {
	fake.upsertMutex.Lock()
	defer fake.upsertMutex.Unlock()
	fake.UpsertStub = nil
	if fake.upsertReturnsOnCall == nil {
		fake.upsertReturnsOnCall = make(map[int]struct {
			result1 *users.User
			result2 error
		})
	}
	fake.upsertReturnsOnCall[i] = struct {
		result1 *users.User
		result2 error
	}{result1, result2}
}

func (fake *FakeUserCollection) WithDependencies(arg1 ...service.Service) {
	fake.withDependenciesMutex.Lock()
	fake.withDependenciesArgsForCall = append(fake.withDependenciesArgsForCall, struct {
		arg1 []service.Service
	}{arg1})
	fake.recordInvocation("WithDependencies", []interface{}{arg1})
	fake.withDependenciesMutex.Unlock()
	if fake.WithDependenciesStub != nil {
		fake.WithDependenciesStub(arg1...)
	}
}

func (fake *FakeUserCollection) WithDependenciesCallCount() int {
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	return len(fake.withDependenciesArgsForCall)
}

func (fake *FakeUserCollection) WithDependenciesCalls(stub func(...service.Service)) {
	fake.withDependenciesMutex.Lock()
	defer fake.withDependenciesMutex.Unlock()
	fake.WithDependenciesStub = stub
}

func (fake *FakeUserCollection) WithDependenciesArgsForCall(i int) []service.Service {
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	argsForCall := fake.withDependenciesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeUserCollection) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.allMutex.RLock()
	defer fake.allMutex.RUnlock()
	fake.byIdMutex.RLock()
	defer fake.byIdMutex.RUnlock()
	fake.byKindMutex.RLock()
	defer fake.byKindMutex.RUnlock()
	fake.byNameAndDivisionMutex.RLock()
	defer fake.byNameAndDivisionMutex.RUnlock()
	fake.byPhoneMutex.RLock()
	defer fake.byPhoneMutex.RUnlock()
	fake.byRangeMutex.RLock()
	defer fake.byRangeMutex.RUnlock()
	fake.dependantsMutex.RLock()
	defer fake.dependantsMutex.RUnlock()
	fake.filterMutex.RLock()
	defer fake.filterMutex.RUnlock()
	fake.initializeMutex.RLock()
	defer fake.initializeMutex.RUnlock()
	fake.insertMutex.RLock()
	defer fake.insertMutex.RUnlock()
	fake.interfaceStubOnlyMutex.RLock()
	defer fake.interfaceStubOnlyMutex.RUnlock()
	fake.nameOfMutex.RLock()
	defer fake.nameOfMutex.RUnlock()
	fake.providerStubOnlyMutex.RLock()
	defer fake.providerStubOnlyMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.stringMutex.RLock()
	defer fake.stringMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.upsertMutex.RLock()
	defer fake.upsertMutex.RUnlock()
	fake.withDependenciesMutex.RLock()
	defer fake.withDependenciesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeUserCollection) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dal_users.UserCollection = new(FakeUserCollection)
