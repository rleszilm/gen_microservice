// Package mongo_dal_single is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package mongo_dal_single

import (
	context "context"
	time "time"

	single "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single"
	dal "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single/dal"
	mongo "github.com/rleszilm/genms/mongo"
	bson "github.com/rleszilm/genms/mongo/bson"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// SingleConfig is a struct that can be used to configure a SingleCollection
type SingleConfig struct {
	Name       string        `envconfig:"name"`
	Database   string        `envconfig:"database"`
	Collection string        `envconfig:"collection"`
	Timeout    time.Duration `envconfig:"timeout" default:"5s"`
}

var (
	singleProjection = bson.M{
		"scalar_int32":   1,
		"scalar_int64":   1,
		"scalar_float32": 1,
		"scalar_float64": 1,
		"scalar_string":  1,
		"scalar_bool":    1,
		"scalar_enum":    1,
		"obj_message":    1,

		"renamed":          1,
		"ignored_postgres": 1,
		"renamed_postgres": 1,
		"ignored_rest":     1,
		"renamed_rest":     1,

		"renamed_mongo": 1,
	}
)

// SingleScanner is an autogenerated struct that
// is used to parse query results.
type SingleScanner struct {
	ScalarInt32   int32                  `bson:"_id,omitempty"`
	ScalarInt64   int64                  `bson:"scalar_int64,omitempty"`
	ScalarFloat32 float32                `bson:"scalar_float32,omitempty"`
	ScalarFloat64 float64                `bson:"scalar_float64,omitempty"`
	ScalarString  string                 `bson:"scalar_string,omitempty"`
	ScalarBool    bool                   `bson:"scalar_bool,omitempty"`
	ScalarEnum    single.Single_Enum     `bson:"scalar_enum,omitempty"`
	ObjMessage    *single.Single_Message `bson:"obj_message,omitempty"`

	Renamed         string `bson:"aliased,omitempty"`
	IgnoredPostgres string `bson:"ignored_postgres,omitempty"`
	RenamedPostgres string `bson:"renamed_postgres,omitempty"`
	IgnoredRest     string `bson:"ignored_rest,omitempty"`
	RenamedRest     string `bson:"renamed_rest,omitempty"`

	RenamedMongo string `bson:"aliased_mongo,omitempty"`
}

// Single returns a new single.Single populated with scanned values.
func (x *SingleScanner) Single() *single.Single {
	y := &single.Single{}

	y.ScalarInt32 = x.ScalarInt32
	y.ScalarInt64 = x.ScalarInt64
	y.ScalarFloat32 = x.ScalarFloat32
	y.ScalarFloat64 = x.ScalarFloat64
	y.ScalarString = x.ScalarString
	y.ScalarBool = x.ScalarBool
	y.ScalarEnum = x.ScalarEnum
	y.ObjMessage = x.ObjMessage

	y.Renamed = x.Renamed
	y.IgnoredPostgres = x.IgnoredPostgres
	y.RenamedPostgres = x.RenamedPostgres
	y.IgnoredRest = x.IgnoredRest
	y.RenamedRest = x.RenamedRest

	y.RenamedMongo = x.RenamedMongo
	return y
}

// SingleCollection is an autogenerated implementation of dal.SingleCollection.
type SingleCollection struct {
	dal.UnimplementedSingleCollection

	name   string
	client mongo.Client
	config *SingleConfig
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *SingleCollection) Initialize(_ context.Context) error {
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *SingleCollection) Shutdown(_ context.Context) error {
	return nil
}

// NameOf returns the name of a service. This must be unique if there are multiple instances of the same
// service.
func (x *SingleCollection) NameOf() string {
	return "mongo_dal_single_" + x.config.Name
}

// String returns a string identifier for the service.
func (x *SingleCollection) String() string {
	return x.NameOf()
}

// find scans the collection for records matching the filter.
func (x *SingleCollection) find(ctx context.Context, label string, filter interface{}, opts ...*mongo.FindOptions) ([]*single.Single, error) {
	ctx, cancel := context.WithTimeout(ctx, x.config.Timeout)
	defer cancel()

	ctx, _ = tag.New(ctx,
		tag.Upsert(mongo.TagCollection, "single"),
		tag.Upsert(mongo.TagInstance, x.name),
		tag.Upsert(mongo.TagMethod, label),
	)
	stats.Record(ctx, mongo.MeasureInflight.M(1))
	start := time.Now()
	defer func(ctx context.Context) {
		stop := time.Now()
		dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
		stats.Record(ctx, mongo.MeasureLatency.M(dur), mongo.MeasureInflight.M(-1))
	}(ctx)

	cur, err := x.client.
		Database(x.config.Database).
		Collection(x.config.Collection).
		Find(ctx, filter, singleProjection, opts...)
	if err != nil {
		mongo.Logs().Error("could not execute rest request:", err)
		stats.Record(ctx, mongo.MeasureError.M(1))
		return nil, err
	}

	vals := []*single.Single{}
	for cur.Next(ctx) {
		obj := &SingleScanner{}
		if err = cur.Decode(obj); err != nil {
			mongo.Logs().Errorf("could not parse %s - %v", label, err)
			stats.Record(ctx, mongo.MeasureError.M(1))
			return nil, err
		}
		vals = append(vals, obj.Single())
	}

	return vals, nil
}

// All implements dal.SingleCollection.All
func (x *SingleCollection) All(ctx context.Context) ([]*single.Single, error) {
	return x.find(ctx, "all", bson.M{})
}

// Filter implements SingleCollectionReader
func (x *SingleCollection) Filter(ctx context.Context, fvs *dal.SingleFieldValues) ([]*single.Single, error) {
	filter := bson.M{}

	if fvs.ScalarInt32 != nil {
		filter["_id"] = *fvs.ScalarInt32
	}
	if fvs.ScalarInt64 != nil {
		filter["scalar_int64"] = *fvs.ScalarInt64
	}
	if fvs.ScalarFloat32 != nil {
		filter["scalar_float32"] = *fvs.ScalarFloat32
	}
	if fvs.ScalarFloat64 != nil {
		filter["scalar_float64"] = *fvs.ScalarFloat64
	}
	if fvs.ScalarString != nil {
		filter["scalar_string"] = *fvs.ScalarString
	}
	if fvs.ScalarBool != nil {
		filter["scalar_bool"] = *fvs.ScalarBool
	}
	if fvs.ScalarEnum != nil {
		filter["scalar_enum"] = *fvs.ScalarEnum
	}
	if fvs.ObjMessage != nil {
		filter["obj_message"] = fvs.ObjMessage
	}

	if fvs.Renamed != nil {
		filter["aliased"] = *fvs.Renamed
	}
	if fvs.IgnoredPostgres != nil {
		filter["ignored_postgres"] = *fvs.IgnoredPostgres
	}
	if fvs.RenamedPostgres != nil {
		filter["renamed_postgres"] = *fvs.RenamedPostgres
	}
	if fvs.IgnoredRest != nil {
		filter["ignored_rest"] = *fvs.IgnoredRest
	}
	if fvs.RenamedRest != nil {
		filter["renamed_rest"] = *fvs.RenamedRest
	}

	if fvs.RenamedMongo != nil {
		filter["aliased_mongo"] = *fvs.RenamedMongo
	}
	return x.find(ctx, "filter", filter)
}

// Insert implements SingleCollectionWriter
func (x *SingleCollection) Insert(ctx context.Context, obj *single.Single) (*single.Single, error) {
	res, err := x.client.
		Database(x.config.Database).
		Collection(x.config.Collection).
		InsertOne(ctx, obj)
	if err != nil {
		return nil, err
	}

	obj.ScalarInt32 = res.InsertedID.(int32)

	return obj, nil
}

// Upsert implements SingleCollectionWriter
func (x *SingleCollection) Upsert(ctx context.Context, _ *single.Single) (*single.Single, error) {
	return nil, nil
}

// Update implements SingleCollectionWriter
func (x *SingleCollection) Update(ctx context.Context, _ *single.Single, _ *dal.SingleFieldValues) (*single.Single, error) {
	return nil, nil
}

// OneParam implements dal.SingleCollection.OneParam
func (x *SingleCollection) OneParam(ctx context.Context, scalar_int32 int32) ([]*single.Single, error) {
	filter := bson.M{
		"_id": scalar_int32,
	}

	return x.find(ctx, "one_param", filter)
}

// MultipleParam implements dal.SingleCollection.MultipleParam
func (x *SingleCollection) MultipleParam(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32) ([]*single.Single, error) {
	filter := bson.M{
		"_id": scalar_int32, "scalar_int64": scalar_int64, "scalar_float32": scalar_float32,
	}

	return x.find(ctx, "multiple_param", filter)
}

// MessageParam implements dal.SingleCollection.MessageParam
func (x *SingleCollection) MessageParam(ctx context.Context, obj_message *single.Single_Message) ([]*single.Single, error) {
	filter := bson.M{
		"obj_message": obj_message,
	}

	return x.find(ctx, "message_param", filter)
}

// WithComparator implements dal.SingleCollection.WithComparator
func (x *SingleCollection) WithComparator(ctx context.Context, scalar_int32 int32) ([]*single.Single, error) {
	filter := bson.M{
		"_id": scalar_int32,
	}

	return x.find(ctx, "with_comparator", filter)
}

// WithRest implements dal.SingleCollection.WithRest
func (x *SingleCollection) WithRest(ctx context.Context, scalar_int32 int32, scalar_int64 int64, scalar_float32 float32, scalar_float64 float64) ([]*single.Single, error) {
	filter := bson.M{
		"_id": scalar_int32, "scalar_int64": scalar_int64, "scalar_float32": scalar_float32, "scalar_float64": scalar_float64,
	}

	return x.find(ctx, "with_rest", filter)
}

// ProviderStubOnly implements dal.SingleCollection.ProviderStubOnly
func (x *SingleCollection) ProviderStubOnly(ctx context.Context) ([]*single.Single, error) {
	filter := bson.M{}

	return x.find(ctx, "provider_stub_only", filter)
}

// NewSingleCollection returns a new SingleCollection.
func NewSingleCollection(instance string, client mongo.Client, config *SingleConfig) (*SingleCollection, error) {
	coll := &SingleCollection{
		name:   instance,
		client: client,
		config: config,
	}

	return coll, nil
}
