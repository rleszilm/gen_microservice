// Package cache_dal_single is generated by protoc-gen-go-genms-dal. *DO NOT EDIT*
package cache_dal_single

import (
	context "context"
	sync "sync"
	time "time"

	cache "github.com/rleszilm/genms/cache"
	keyvalue "github.com/rleszilm/genms/cmd/protoc-gen-go-genms-dal/example/single/dal/keyvalue"
	stats "go.opencensus.io/stats"
	tag "go.opencensus.io/tag"
)

// SingleUpdater is an autogenerated implementation of dal.SingleUpdater.
type SingleUpdater struct {
	name     string
	reader   keyvalue.SingleReadAller
	writer   keyvalue.SingleWriter
	key      keyvalue.SingleKeyFunc
	interval time.Duration
	init     sync.Once
	done     chan struct{}
}

// Initialize initializes and starts the service. Initialize should panic in case of
// any errors. It is intended that Initialize be called only once during the service life-cycle.
func (x *SingleUpdater) Initialize(ctx context.Context) error {
	go x.init.Do(func() { x.update(ctx) })
	return nil
}

// Shutdown closes the long-running instance, or service.
func (x *SingleUpdater) Shutdown(_ context.Context) error {
	return nil
}

func (x *SingleUpdater) update(ctx context.Context) {
	ctx, _ = tag.New(ctx,
		tag.Upsert(cache.TagCollection, "single"),
		tag.Upsert(cache.TagInstance, x.name),
		tag.Upsert(cache.TagMethod, "update"),
		tag.Upsert(cache.TagType, "updater"),
	)

	ticker := time.NewTicker(0)
	for {
		select {
		case <-ctx.Done():
			return
		case <-ticker.C:
			start := time.Now()
			stats.Record(ctx, cache.MeasureInflight.M(1))

			vals, err := x.reader.All(ctx)
			if err == nil {
				for _, val := range vals {
					if err = x.writer.SetByKey(ctx, x.key(val), val); err != nil {
						break
					}
				}
			}
			stats.Record(ctx, cache.MeasureInflight.M(-1))

			if err != nil {
				stats.Record(ctx, cache.MeasureError.M(1))
			}

			stop := time.Now()
			dur := float64(stop.Sub(start).Nanoseconds()) / float64(time.Millisecond)
			stats.Record(ctx, cache.MeasureLatency.M(dur))

			if x.interval == 0 {
				return
			}
			ticker.Reset(x.interval)
		}
	}
}

// NewSingleUpdater returns a new SingleUpdater.
func NewSingleUpdater(name string, r keyvalue.SingleReadAller, w keyvalue.SingleWriter, k keyvalue.SingleKeyFunc, i time.Duration) *SingleUpdater {
	return &SingleUpdater{
		name:     name,
		reader:   r,
		writer:   w,
		key:      k,
		interval: i,
		done:     make(chan struct{}),
	}
}
